Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON

Grammar

Rule 0     S' -> line
Rule 1     line -> expr SEMICOLON
Rule 2     expr -> INTEGER
Rule 3     expr -> FLOAT
Rule 4     expr -> STRING
Rule 5     expr -> BOOLEAN
Rule 6     expr -> VARIABLE
Rule 7     expr -> list
Rule 8     expr -> tuple
Rule 9     expr -> expr indexSequenceList EQ expr
Rule 10    expr -> HASHTAG INTEGER expr
Rule 11    tuple -> L_PAREN sequence R_PAREN
Rule 12    tuple -> L_PAREN R_PAREN
Rule 13    expr -> expr POW expr
Rule 14    expr -> expr MULT expr
Rule 15    expr -> expr DIVINT expr
Rule 16    expr -> expr DIV expr
Rule 17    expr -> expr MOD expr
Rule 18    expr -> expr PLUS expr
Rule 19    expr -> expr MINUS expr
Rule 20    expr -> MINUS expr
Rule 21    expr -> expr AND_ALSO expr
Rule 22    expr -> expr OR_ELSE expr
Rule 23    expr -> expr LTE expr
Rule 24    expr -> expr GTE expr
Rule 25    expr -> expr EQ_EQ expr
Rule 26    expr -> expr NEQ expr
Rule 27    expr -> expr LT expr
Rule 28    expr -> expr GT expr
Rule 29    expr -> expr IN expr
Rule 30    expr -> expr CONS expr
Rule 31    expr -> NOT expr
Rule 32    expr -> expr L_BRACK expr R_BRACK
Rule 33    list -> L_BRACK sequence R_BRACK
Rule 34    list -> L_BRACK R_BRACK
Rule 35    sequence -> expr COMMA sequence
Rule 36    sequence -> expr
Rule 37    expr -> L_PAREN expr R_PAREN
Rule 38    expr -> expr EQ expr
Rule 39    indexSequenceList -> indexSequenceList indexTkn
Rule 40    indexSequenceList -> indexTkn
Rule 41    indexTkn -> L_BRACK INTEGER R_BRACK

Terminals, with rules where they appear

AND_ALSO             : 21
BOOLEAN              : 5
COLON                : 
COMMA                : 35
CONS                 : 30
DIV                  : 16
DIVINT               : 15
EQ                   : 9 38
EQ_EQ                : 25
FLOAT                : 3
GT                   : 28
GTE                  : 24
HASHTAG              : 10
IN                   : 29
INTEGER              : 2 10 41
LT                   : 27
LTE                  : 23
L_BRACK              : 32 33 34 41
L_PAREN              : 11 12 37
MINUS                : 19 20
MOD                  : 17
MULT                 : 14
NEQ                  : 26
NOT                  : 31
OR_ELSE              : 22
PLUS                 : 18
POW                  : 13
R_BRACK              : 32 33 34 41
R_PAREN              : 11 12 37
SEMICOLON            : 1
STRING               : 4
VARIABLE             : 6
error                : 

Nonterminals, with rules where they appear

expr                 : 1 9 9 10 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 32 32 35 36 37 38 38
indexSequenceList    : 9 39
indexTkn             : 39 40
line                 : 0
list                 : 7
sequence             : 11 33 35
tuple                : 8

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . expr SEMICOLON
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    line                           shift and go to state 1
    expr                           shift and go to state 2
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 1

    (0) S' -> line .



state 2

    (1) line -> expr . SEMICOLON
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       shift and go to state 15
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND_ALSO        shift and go to state 25
    OR_ELSE         shift and go to state 26
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35
    EQ              shift and go to state 17

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 3

    (2) expr -> INTEGER .

    SEMICOLON       reduce using rule 2 (expr -> INTEGER .)
    POW             reduce using rule 2 (expr -> INTEGER .)
    MULT            reduce using rule 2 (expr -> INTEGER .)
    DIVINT          reduce using rule 2 (expr -> INTEGER .)
    DIV             reduce using rule 2 (expr -> INTEGER .)
    MOD             reduce using rule 2 (expr -> INTEGER .)
    PLUS            reduce using rule 2 (expr -> INTEGER .)
    MINUS           reduce using rule 2 (expr -> INTEGER .)
    AND_ALSO        reduce using rule 2 (expr -> INTEGER .)
    OR_ELSE         reduce using rule 2 (expr -> INTEGER .)
    LTE             reduce using rule 2 (expr -> INTEGER .)
    GTE             reduce using rule 2 (expr -> INTEGER .)
    EQ_EQ           reduce using rule 2 (expr -> INTEGER .)
    NEQ             reduce using rule 2 (expr -> INTEGER .)
    LT              reduce using rule 2 (expr -> INTEGER .)
    GT              reduce using rule 2 (expr -> INTEGER .)
    IN              reduce using rule 2 (expr -> INTEGER .)
    CONS            reduce using rule 2 (expr -> INTEGER .)
    L_BRACK         reduce using rule 2 (expr -> INTEGER .)
    EQ              reduce using rule 2 (expr -> INTEGER .)
    COMMA           reduce using rule 2 (expr -> INTEGER .)
    R_BRACK         reduce using rule 2 (expr -> INTEGER .)
    R_PAREN         reduce using rule 2 (expr -> INTEGER .)


state 4

    (3) expr -> FLOAT .

    SEMICOLON       reduce using rule 3 (expr -> FLOAT .)
    POW             reduce using rule 3 (expr -> FLOAT .)
    MULT            reduce using rule 3 (expr -> FLOAT .)
    DIVINT          reduce using rule 3 (expr -> FLOAT .)
    DIV             reduce using rule 3 (expr -> FLOAT .)
    MOD             reduce using rule 3 (expr -> FLOAT .)
    PLUS            reduce using rule 3 (expr -> FLOAT .)
    MINUS           reduce using rule 3 (expr -> FLOAT .)
    AND_ALSO        reduce using rule 3 (expr -> FLOAT .)
    OR_ELSE         reduce using rule 3 (expr -> FLOAT .)
    LTE             reduce using rule 3 (expr -> FLOAT .)
    GTE             reduce using rule 3 (expr -> FLOAT .)
    EQ_EQ           reduce using rule 3 (expr -> FLOAT .)
    NEQ             reduce using rule 3 (expr -> FLOAT .)
    LT              reduce using rule 3 (expr -> FLOAT .)
    GT              reduce using rule 3 (expr -> FLOAT .)
    IN              reduce using rule 3 (expr -> FLOAT .)
    CONS            reduce using rule 3 (expr -> FLOAT .)
    L_BRACK         reduce using rule 3 (expr -> FLOAT .)
    EQ              reduce using rule 3 (expr -> FLOAT .)
    COMMA           reduce using rule 3 (expr -> FLOAT .)
    R_BRACK         reduce using rule 3 (expr -> FLOAT .)
    R_PAREN         reduce using rule 3 (expr -> FLOAT .)


state 5

    (4) expr -> STRING .

    SEMICOLON       reduce using rule 4 (expr -> STRING .)
    POW             reduce using rule 4 (expr -> STRING .)
    MULT            reduce using rule 4 (expr -> STRING .)
    DIVINT          reduce using rule 4 (expr -> STRING .)
    DIV             reduce using rule 4 (expr -> STRING .)
    MOD             reduce using rule 4 (expr -> STRING .)
    PLUS            reduce using rule 4 (expr -> STRING .)
    MINUS           reduce using rule 4 (expr -> STRING .)
    AND_ALSO        reduce using rule 4 (expr -> STRING .)
    OR_ELSE         reduce using rule 4 (expr -> STRING .)
    LTE             reduce using rule 4 (expr -> STRING .)
    GTE             reduce using rule 4 (expr -> STRING .)
    EQ_EQ           reduce using rule 4 (expr -> STRING .)
    NEQ             reduce using rule 4 (expr -> STRING .)
    LT              reduce using rule 4 (expr -> STRING .)
    GT              reduce using rule 4 (expr -> STRING .)
    IN              reduce using rule 4 (expr -> STRING .)
    CONS            reduce using rule 4 (expr -> STRING .)
    L_BRACK         reduce using rule 4 (expr -> STRING .)
    EQ              reduce using rule 4 (expr -> STRING .)
    COMMA           reduce using rule 4 (expr -> STRING .)
    R_BRACK         reduce using rule 4 (expr -> STRING .)
    R_PAREN         reduce using rule 4 (expr -> STRING .)


state 6

    (5) expr -> BOOLEAN .

    SEMICOLON       reduce using rule 5 (expr -> BOOLEAN .)
    POW             reduce using rule 5 (expr -> BOOLEAN .)
    MULT            reduce using rule 5 (expr -> BOOLEAN .)
    DIVINT          reduce using rule 5 (expr -> BOOLEAN .)
    DIV             reduce using rule 5 (expr -> BOOLEAN .)
    MOD             reduce using rule 5 (expr -> BOOLEAN .)
    PLUS            reduce using rule 5 (expr -> BOOLEAN .)
    MINUS           reduce using rule 5 (expr -> BOOLEAN .)
    AND_ALSO        reduce using rule 5 (expr -> BOOLEAN .)
    OR_ELSE         reduce using rule 5 (expr -> BOOLEAN .)
    LTE             reduce using rule 5 (expr -> BOOLEAN .)
    GTE             reduce using rule 5 (expr -> BOOLEAN .)
    EQ_EQ           reduce using rule 5 (expr -> BOOLEAN .)
    NEQ             reduce using rule 5 (expr -> BOOLEAN .)
    LT              reduce using rule 5 (expr -> BOOLEAN .)
    GT              reduce using rule 5 (expr -> BOOLEAN .)
    IN              reduce using rule 5 (expr -> BOOLEAN .)
    CONS            reduce using rule 5 (expr -> BOOLEAN .)
    L_BRACK         reduce using rule 5 (expr -> BOOLEAN .)
    EQ              reduce using rule 5 (expr -> BOOLEAN .)
    COMMA           reduce using rule 5 (expr -> BOOLEAN .)
    R_BRACK         reduce using rule 5 (expr -> BOOLEAN .)
    R_PAREN         reduce using rule 5 (expr -> BOOLEAN .)


state 7

    (6) expr -> VARIABLE .

    SEMICOLON       reduce using rule 6 (expr -> VARIABLE .)
    POW             reduce using rule 6 (expr -> VARIABLE .)
    MULT            reduce using rule 6 (expr -> VARIABLE .)
    DIVINT          reduce using rule 6 (expr -> VARIABLE .)
    DIV             reduce using rule 6 (expr -> VARIABLE .)
    MOD             reduce using rule 6 (expr -> VARIABLE .)
    PLUS            reduce using rule 6 (expr -> VARIABLE .)
    MINUS           reduce using rule 6 (expr -> VARIABLE .)
    AND_ALSO        reduce using rule 6 (expr -> VARIABLE .)
    OR_ELSE         reduce using rule 6 (expr -> VARIABLE .)
    LTE             reduce using rule 6 (expr -> VARIABLE .)
    GTE             reduce using rule 6 (expr -> VARIABLE .)
    EQ_EQ           reduce using rule 6 (expr -> VARIABLE .)
    NEQ             reduce using rule 6 (expr -> VARIABLE .)
    LT              reduce using rule 6 (expr -> VARIABLE .)
    GT              reduce using rule 6 (expr -> VARIABLE .)
    IN              reduce using rule 6 (expr -> VARIABLE .)
    CONS            reduce using rule 6 (expr -> VARIABLE .)
    L_BRACK         reduce using rule 6 (expr -> VARIABLE .)
    EQ              reduce using rule 6 (expr -> VARIABLE .)
    COMMA           reduce using rule 6 (expr -> VARIABLE .)
    R_BRACK         reduce using rule 6 (expr -> VARIABLE .)
    R_PAREN         reduce using rule 6 (expr -> VARIABLE .)


state 8

    (7) expr -> list .

    SEMICOLON       reduce using rule 7 (expr -> list .)
    POW             reduce using rule 7 (expr -> list .)
    MULT            reduce using rule 7 (expr -> list .)
    DIVINT          reduce using rule 7 (expr -> list .)
    DIV             reduce using rule 7 (expr -> list .)
    MOD             reduce using rule 7 (expr -> list .)
    PLUS            reduce using rule 7 (expr -> list .)
    MINUS           reduce using rule 7 (expr -> list .)
    AND_ALSO        reduce using rule 7 (expr -> list .)
    OR_ELSE         reduce using rule 7 (expr -> list .)
    LTE             reduce using rule 7 (expr -> list .)
    GTE             reduce using rule 7 (expr -> list .)
    EQ_EQ           reduce using rule 7 (expr -> list .)
    NEQ             reduce using rule 7 (expr -> list .)
    LT              reduce using rule 7 (expr -> list .)
    GT              reduce using rule 7 (expr -> list .)
    IN              reduce using rule 7 (expr -> list .)
    CONS            reduce using rule 7 (expr -> list .)
    L_BRACK         reduce using rule 7 (expr -> list .)
    EQ              reduce using rule 7 (expr -> list .)
    COMMA           reduce using rule 7 (expr -> list .)
    R_BRACK         reduce using rule 7 (expr -> list .)
    R_PAREN         reduce using rule 7 (expr -> list .)


state 9

    (8) expr -> tuple .

    SEMICOLON       reduce using rule 8 (expr -> tuple .)
    POW             reduce using rule 8 (expr -> tuple .)
    MULT            reduce using rule 8 (expr -> tuple .)
    DIVINT          reduce using rule 8 (expr -> tuple .)
    DIV             reduce using rule 8 (expr -> tuple .)
    MOD             reduce using rule 8 (expr -> tuple .)
    PLUS            reduce using rule 8 (expr -> tuple .)
    MINUS           reduce using rule 8 (expr -> tuple .)
    AND_ALSO        reduce using rule 8 (expr -> tuple .)
    OR_ELSE         reduce using rule 8 (expr -> tuple .)
    LTE             reduce using rule 8 (expr -> tuple .)
    GTE             reduce using rule 8 (expr -> tuple .)
    EQ_EQ           reduce using rule 8 (expr -> tuple .)
    NEQ             reduce using rule 8 (expr -> tuple .)
    LT              reduce using rule 8 (expr -> tuple .)
    GT              reduce using rule 8 (expr -> tuple .)
    IN              reduce using rule 8 (expr -> tuple .)
    CONS            reduce using rule 8 (expr -> tuple .)
    L_BRACK         reduce using rule 8 (expr -> tuple .)
    EQ              reduce using rule 8 (expr -> tuple .)
    COMMA           reduce using rule 8 (expr -> tuple .)
    R_BRACK         reduce using rule 8 (expr -> tuple .)
    R_PAREN         reduce using rule 8 (expr -> tuple .)


state 10

    (10) expr -> HASHTAG . INTEGER expr

    INTEGER         shift and go to state 37


state 11

    (20) expr -> MINUS . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 38
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 12

    (31) expr -> NOT . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 39
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 13

    (33) list -> L_BRACK . sequence R_BRACK
    (34) list -> L_BRACK . R_BRACK
    (35) sequence -> . expr COMMA sequence
    (36) sequence -> . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    R_BRACK         shift and go to state 41
    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    sequence                       shift and go to state 40
    expr                           shift and go to state 42
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 14

    (37) expr -> L_PAREN . expr R_PAREN
    (11) tuple -> L_PAREN . sequence R_PAREN
    (12) tuple -> L_PAREN . R_PAREN
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (35) sequence -> . expr COMMA sequence
    (36) sequence -> . expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    R_PAREN         shift and go to state 44
    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 43
    sequence                       shift and go to state 45
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 15

    (1) line -> expr SEMICOLON .

    $end            reduce using rule 1 (line -> expr SEMICOLON .)


state 16

    (9) expr -> expr indexSequenceList . EQ expr
    (39) indexSequenceList -> indexSequenceList . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    EQ              shift and go to state 46
    L_BRACK         shift and go to state 48

    indexTkn                       shift and go to state 47

state 17

    (38) expr -> expr EQ . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 49
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 18

    (13) expr -> expr POW . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 50
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 19

    (14) expr -> expr MULT . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 51
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 20

    (15) expr -> expr DIVINT . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 52
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 21

    (16) expr -> expr DIV . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 53
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 22

    (17) expr -> expr MOD . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 54
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 23

    (18) expr -> expr PLUS . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 55
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 24

    (19) expr -> expr MINUS . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 56
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 25

    (21) expr -> expr AND_ALSO . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 57
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 26

    (22) expr -> expr OR_ELSE . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 58
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 27

    (23) expr -> expr LTE . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 59
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 28

    (24) expr -> expr GTE . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 60
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 29

    (25) expr -> expr EQ_EQ . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 61
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 30

    (26) expr -> expr NEQ . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 62
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 31

    (27) expr -> expr LT . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 63
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 32

    (28) expr -> expr GT . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 64
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 33

    (29) expr -> expr IN . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 65
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 34

    (30) expr -> expr CONS . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 66
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 35

    (32) expr -> expr L_BRACK . expr R_BRACK
    (41) indexTkn -> L_BRACK . INTEGER R_BRACK
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 68
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 67
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 36

    (40) indexSequenceList -> indexTkn .

    EQ              reduce using rule 40 (indexSequenceList -> indexTkn .)
    L_BRACK         reduce using rule 40 (indexSequenceList -> indexTkn .)


state 37

    (10) expr -> HASHTAG INTEGER . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 69
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 38

    (20) expr -> MINUS expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 20 (expr -> MINUS expr .)
    MULT            reduce using rule 20 (expr -> MINUS expr .)
    DIVINT          reduce using rule 20 (expr -> MINUS expr .)
    DIV             reduce using rule 20 (expr -> MINUS expr .)
    MOD             reduce using rule 20 (expr -> MINUS expr .)
    PLUS            reduce using rule 20 (expr -> MINUS expr .)
    MINUS           reduce using rule 20 (expr -> MINUS expr .)
    AND_ALSO        reduce using rule 20 (expr -> MINUS expr .)
    OR_ELSE         reduce using rule 20 (expr -> MINUS expr .)
    LTE             reduce using rule 20 (expr -> MINUS expr .)
    GTE             reduce using rule 20 (expr -> MINUS expr .)
    EQ_EQ           reduce using rule 20 (expr -> MINUS expr .)
    NEQ             reduce using rule 20 (expr -> MINUS expr .)
    LT              reduce using rule 20 (expr -> MINUS expr .)
    GT              reduce using rule 20 (expr -> MINUS expr .)
    IN              reduce using rule 20 (expr -> MINUS expr .)
    CONS            reduce using rule 20 (expr -> MINUS expr .)
    EQ              reduce using rule 20 (expr -> MINUS expr .)
    COMMA           reduce using rule 20 (expr -> MINUS expr .)
    R_BRACK         reduce using rule 20 (expr -> MINUS expr .)
    R_PAREN         reduce using rule 20 (expr -> MINUS expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 20 (expr -> MINUS expr .) ]
  ! L_BRACK         [ reduce using rule 20 (expr -> MINUS expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 39

    (31) expr -> NOT expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 31 (expr -> NOT expr .)
    MULT            reduce using rule 31 (expr -> NOT expr .)
    DIVINT          reduce using rule 31 (expr -> NOT expr .)
    DIV             reduce using rule 31 (expr -> NOT expr .)
    MOD             reduce using rule 31 (expr -> NOT expr .)
    PLUS            reduce using rule 31 (expr -> NOT expr .)
    MINUS           reduce using rule 31 (expr -> NOT expr .)
    AND_ALSO        reduce using rule 31 (expr -> NOT expr .)
    OR_ELSE         reduce using rule 31 (expr -> NOT expr .)
    LTE             reduce using rule 31 (expr -> NOT expr .)
    GTE             reduce using rule 31 (expr -> NOT expr .)
    EQ_EQ           reduce using rule 31 (expr -> NOT expr .)
    NEQ             reduce using rule 31 (expr -> NOT expr .)
    LT              reduce using rule 31 (expr -> NOT expr .)
    GT              reduce using rule 31 (expr -> NOT expr .)
    IN              reduce using rule 31 (expr -> NOT expr .)
    CONS            reduce using rule 31 (expr -> NOT expr .)
    EQ              reduce using rule 31 (expr -> NOT expr .)
    COMMA           reduce using rule 31 (expr -> NOT expr .)
    R_BRACK         reduce using rule 31 (expr -> NOT expr .)
    R_PAREN         reduce using rule 31 (expr -> NOT expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 31 (expr -> NOT expr .) ]
  ! L_BRACK         [ reduce using rule 31 (expr -> NOT expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 40

    (33) list -> L_BRACK sequence . R_BRACK

    R_BRACK         shift and go to state 70


state 41

    (34) list -> L_BRACK R_BRACK .

    SEMICOLON       reduce using rule 34 (list -> L_BRACK R_BRACK .)
    POW             reduce using rule 34 (list -> L_BRACK R_BRACK .)
    MULT            reduce using rule 34 (list -> L_BRACK R_BRACK .)
    DIVINT          reduce using rule 34 (list -> L_BRACK R_BRACK .)
    DIV             reduce using rule 34 (list -> L_BRACK R_BRACK .)
    MOD             reduce using rule 34 (list -> L_BRACK R_BRACK .)
    PLUS            reduce using rule 34 (list -> L_BRACK R_BRACK .)
    MINUS           reduce using rule 34 (list -> L_BRACK R_BRACK .)
    AND_ALSO        reduce using rule 34 (list -> L_BRACK R_BRACK .)
    OR_ELSE         reduce using rule 34 (list -> L_BRACK R_BRACK .)
    LTE             reduce using rule 34 (list -> L_BRACK R_BRACK .)
    GTE             reduce using rule 34 (list -> L_BRACK R_BRACK .)
    EQ_EQ           reduce using rule 34 (list -> L_BRACK R_BRACK .)
    NEQ             reduce using rule 34 (list -> L_BRACK R_BRACK .)
    LT              reduce using rule 34 (list -> L_BRACK R_BRACK .)
    GT              reduce using rule 34 (list -> L_BRACK R_BRACK .)
    IN              reduce using rule 34 (list -> L_BRACK R_BRACK .)
    CONS            reduce using rule 34 (list -> L_BRACK R_BRACK .)
    L_BRACK         reduce using rule 34 (list -> L_BRACK R_BRACK .)
    EQ              reduce using rule 34 (list -> L_BRACK R_BRACK .)
    COMMA           reduce using rule 34 (list -> L_BRACK R_BRACK .)
    R_BRACK         reduce using rule 34 (list -> L_BRACK R_BRACK .)
    R_PAREN         reduce using rule 34 (list -> L_BRACK R_BRACK .)


state 42

    (35) sequence -> expr . COMMA sequence
    (36) sequence -> expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    COMMA           shift and go to state 71
    R_BRACK         reduce using rule 36 (sequence -> expr .)
    R_PAREN         reduce using rule 36 (sequence -> expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND_ALSO        shift and go to state 25
    OR_ELSE         shift and go to state 26
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35
    EQ              shift and go to state 17

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 43

    (37) expr -> L_PAREN expr . R_PAREN
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (35) sequence -> expr . COMMA sequence
    (36) sequence -> expr .
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

  ! shift/reduce conflict for R_PAREN resolved as shift
    R_PAREN         shift and go to state 72
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND_ALSO        shift and go to state 25
    OR_ELSE         shift and go to state 26
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35
    EQ              shift and go to state 17
    COMMA           shift and go to state 71

  ! R_PAREN         [ reduce using rule 36 (sequence -> expr .) ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 44

    (12) tuple -> L_PAREN R_PAREN .

    SEMICOLON       reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    POW             reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    MULT            reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    DIVINT          reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    DIV             reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    MOD             reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    PLUS            reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    MINUS           reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    AND_ALSO        reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    OR_ELSE         reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    LTE             reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    GTE             reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    EQ_EQ           reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    NEQ             reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    LT              reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    GT              reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    IN              reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    CONS            reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    L_BRACK         reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    EQ              reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    COMMA           reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    R_BRACK         reduce using rule 12 (tuple -> L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 12 (tuple -> L_PAREN R_PAREN .)


state 45

    (11) tuple -> L_PAREN sequence . R_PAREN

    R_PAREN         shift and go to state 73


state 46

    (9) expr -> expr indexSequenceList EQ . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 74
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 47

    (39) indexSequenceList -> indexSequenceList indexTkn .

    EQ              reduce using rule 39 (indexSequenceList -> indexSequenceList indexTkn .)
    L_BRACK         reduce using rule 39 (indexSequenceList -> indexSequenceList indexTkn .)


state 48

    (41) indexTkn -> L_BRACK . INTEGER R_BRACK

    INTEGER         shift and go to state 75


state 49

    (38) expr -> expr EQ expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVINT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND_ALSO resolved as shift
  ! shift/reduce conflict for OR_ELSE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for IN resolved as shift
  ! shift/reduce conflict for CONS resolved as shift
  ! shift/reduce conflict for L_BRACK resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
    SEMICOLON       reduce using rule 38 (expr -> expr EQ expr .)
    COMMA           reduce using rule 38 (expr -> expr EQ expr .)
    R_BRACK         reduce using rule 38 (expr -> expr EQ expr .)
    R_PAREN         reduce using rule 38 (expr -> expr EQ expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND_ALSO        shift and go to state 25
    OR_ELSE         shift and go to state 26
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35
    EQ              shift and go to state 17

  ! POW             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! MULT            [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! DIVINT          [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! DIV             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! AND_ALSO        [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! OR_ELSE         [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! NEQ             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! IN              [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! CONS            [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! L_BRACK         [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! EQ              [ reduce using rule 38 (expr -> expr EQ expr .) ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 50

    (13) expr -> expr POW expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 13 (expr -> expr POW expr .)
    MULT            reduce using rule 13 (expr -> expr POW expr .)
    DIVINT          reduce using rule 13 (expr -> expr POW expr .)
    DIV             reduce using rule 13 (expr -> expr POW expr .)
    MOD             reduce using rule 13 (expr -> expr POW expr .)
    PLUS            reduce using rule 13 (expr -> expr POW expr .)
    MINUS           reduce using rule 13 (expr -> expr POW expr .)
    AND_ALSO        reduce using rule 13 (expr -> expr POW expr .)
    OR_ELSE         reduce using rule 13 (expr -> expr POW expr .)
    LTE             reduce using rule 13 (expr -> expr POW expr .)
    GTE             reduce using rule 13 (expr -> expr POW expr .)
    EQ_EQ           reduce using rule 13 (expr -> expr POW expr .)
    NEQ             reduce using rule 13 (expr -> expr POW expr .)
    LT              reduce using rule 13 (expr -> expr POW expr .)
    GT              reduce using rule 13 (expr -> expr POW expr .)
    IN              reduce using rule 13 (expr -> expr POW expr .)
    CONS            reduce using rule 13 (expr -> expr POW expr .)
    EQ              reduce using rule 13 (expr -> expr POW expr .)
    COMMA           reduce using rule 13 (expr -> expr POW expr .)
    R_BRACK         reduce using rule 13 (expr -> expr POW expr .)
    R_PAREN         reduce using rule 13 (expr -> expr POW expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 13 (expr -> expr POW expr .) ]
  ! L_BRACK         [ reduce using rule 13 (expr -> expr POW expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 51

    (14) expr -> expr MULT expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 14 (expr -> expr MULT expr .)
    MULT            reduce using rule 14 (expr -> expr MULT expr .)
    DIVINT          reduce using rule 14 (expr -> expr MULT expr .)
    DIV             reduce using rule 14 (expr -> expr MULT expr .)
    MOD             reduce using rule 14 (expr -> expr MULT expr .)
    PLUS            reduce using rule 14 (expr -> expr MULT expr .)
    MINUS           reduce using rule 14 (expr -> expr MULT expr .)
    AND_ALSO        reduce using rule 14 (expr -> expr MULT expr .)
    OR_ELSE         reduce using rule 14 (expr -> expr MULT expr .)
    LTE             reduce using rule 14 (expr -> expr MULT expr .)
    GTE             reduce using rule 14 (expr -> expr MULT expr .)
    EQ_EQ           reduce using rule 14 (expr -> expr MULT expr .)
    NEQ             reduce using rule 14 (expr -> expr MULT expr .)
    LT              reduce using rule 14 (expr -> expr MULT expr .)
    GT              reduce using rule 14 (expr -> expr MULT expr .)
    IN              reduce using rule 14 (expr -> expr MULT expr .)
    CONS            reduce using rule 14 (expr -> expr MULT expr .)
    EQ              reduce using rule 14 (expr -> expr MULT expr .)
    COMMA           reduce using rule 14 (expr -> expr MULT expr .)
    R_BRACK         reduce using rule 14 (expr -> expr MULT expr .)
    R_PAREN         reduce using rule 14 (expr -> expr MULT expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 14 (expr -> expr MULT expr .) ]
  ! L_BRACK         [ reduce using rule 14 (expr -> expr MULT expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 52

    (15) expr -> expr DIVINT expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 15 (expr -> expr DIVINT expr .)
    MULT            reduce using rule 15 (expr -> expr DIVINT expr .)
    DIVINT          reduce using rule 15 (expr -> expr DIVINT expr .)
    DIV             reduce using rule 15 (expr -> expr DIVINT expr .)
    MOD             reduce using rule 15 (expr -> expr DIVINT expr .)
    PLUS            reduce using rule 15 (expr -> expr DIVINT expr .)
    MINUS           reduce using rule 15 (expr -> expr DIVINT expr .)
    AND_ALSO        reduce using rule 15 (expr -> expr DIVINT expr .)
    OR_ELSE         reduce using rule 15 (expr -> expr DIVINT expr .)
    LTE             reduce using rule 15 (expr -> expr DIVINT expr .)
    GTE             reduce using rule 15 (expr -> expr DIVINT expr .)
    EQ_EQ           reduce using rule 15 (expr -> expr DIVINT expr .)
    NEQ             reduce using rule 15 (expr -> expr DIVINT expr .)
    LT              reduce using rule 15 (expr -> expr DIVINT expr .)
    GT              reduce using rule 15 (expr -> expr DIVINT expr .)
    IN              reduce using rule 15 (expr -> expr DIVINT expr .)
    CONS            reduce using rule 15 (expr -> expr DIVINT expr .)
    EQ              reduce using rule 15 (expr -> expr DIVINT expr .)
    COMMA           reduce using rule 15 (expr -> expr DIVINT expr .)
    R_BRACK         reduce using rule 15 (expr -> expr DIVINT expr .)
    R_PAREN         reduce using rule 15 (expr -> expr DIVINT expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 15 (expr -> expr DIVINT expr .) ]
  ! L_BRACK         [ reduce using rule 15 (expr -> expr DIVINT expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 53

    (16) expr -> expr DIV expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 16 (expr -> expr DIV expr .)
    MULT            reduce using rule 16 (expr -> expr DIV expr .)
    DIVINT          reduce using rule 16 (expr -> expr DIV expr .)
    DIV             reduce using rule 16 (expr -> expr DIV expr .)
    MOD             reduce using rule 16 (expr -> expr DIV expr .)
    PLUS            reduce using rule 16 (expr -> expr DIV expr .)
    MINUS           reduce using rule 16 (expr -> expr DIV expr .)
    AND_ALSO        reduce using rule 16 (expr -> expr DIV expr .)
    OR_ELSE         reduce using rule 16 (expr -> expr DIV expr .)
    LTE             reduce using rule 16 (expr -> expr DIV expr .)
    GTE             reduce using rule 16 (expr -> expr DIV expr .)
    EQ_EQ           reduce using rule 16 (expr -> expr DIV expr .)
    NEQ             reduce using rule 16 (expr -> expr DIV expr .)
    LT              reduce using rule 16 (expr -> expr DIV expr .)
    GT              reduce using rule 16 (expr -> expr DIV expr .)
    IN              reduce using rule 16 (expr -> expr DIV expr .)
    CONS            reduce using rule 16 (expr -> expr DIV expr .)
    EQ              reduce using rule 16 (expr -> expr DIV expr .)
    COMMA           reduce using rule 16 (expr -> expr DIV expr .)
    R_BRACK         reduce using rule 16 (expr -> expr DIV expr .)
    R_PAREN         reduce using rule 16 (expr -> expr DIV expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 16 (expr -> expr DIV expr .) ]
  ! L_BRACK         [ reduce using rule 16 (expr -> expr DIV expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 54

    (17) expr -> expr MOD expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 17 (expr -> expr MOD expr .)
    MULT            reduce using rule 17 (expr -> expr MOD expr .)
    DIVINT          reduce using rule 17 (expr -> expr MOD expr .)
    DIV             reduce using rule 17 (expr -> expr MOD expr .)
    MOD             reduce using rule 17 (expr -> expr MOD expr .)
    PLUS            reduce using rule 17 (expr -> expr MOD expr .)
    MINUS           reduce using rule 17 (expr -> expr MOD expr .)
    AND_ALSO        reduce using rule 17 (expr -> expr MOD expr .)
    OR_ELSE         reduce using rule 17 (expr -> expr MOD expr .)
    LTE             reduce using rule 17 (expr -> expr MOD expr .)
    GTE             reduce using rule 17 (expr -> expr MOD expr .)
    EQ_EQ           reduce using rule 17 (expr -> expr MOD expr .)
    NEQ             reduce using rule 17 (expr -> expr MOD expr .)
    LT              reduce using rule 17 (expr -> expr MOD expr .)
    GT              reduce using rule 17 (expr -> expr MOD expr .)
    IN              reduce using rule 17 (expr -> expr MOD expr .)
    CONS            reduce using rule 17 (expr -> expr MOD expr .)
    EQ              reduce using rule 17 (expr -> expr MOD expr .)
    COMMA           reduce using rule 17 (expr -> expr MOD expr .)
    R_BRACK         reduce using rule 17 (expr -> expr MOD expr .)
    R_PAREN         reduce using rule 17 (expr -> expr MOD expr .)
    POW             shift and go to state 18
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 17 (expr -> expr MOD expr .) ]
  ! L_BRACK         [ reduce using rule 17 (expr -> expr MOD expr .) ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 55

    (18) expr -> expr PLUS expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 18 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 18 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 18 (expr -> expr PLUS expr .)
    AND_ALSO        reduce using rule 18 (expr -> expr PLUS expr .)
    OR_ELSE         reduce using rule 18 (expr -> expr PLUS expr .)
    LTE             reduce using rule 18 (expr -> expr PLUS expr .)
    GTE             reduce using rule 18 (expr -> expr PLUS expr .)
    EQ_EQ           reduce using rule 18 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 18 (expr -> expr PLUS expr .)
    LT              reduce using rule 18 (expr -> expr PLUS expr .)
    GT              reduce using rule 18 (expr -> expr PLUS expr .)
    IN              reduce using rule 18 (expr -> expr PLUS expr .)
    CONS            reduce using rule 18 (expr -> expr PLUS expr .)
    EQ              reduce using rule 18 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 18 (expr -> expr PLUS expr .)
    R_BRACK         reduce using rule 18 (expr -> expr PLUS expr .)
    R_PAREN         reduce using rule 18 (expr -> expr PLUS expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! MULT            [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! DIVINT          [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! L_BRACK         [ reduce using rule 18 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 56

    (19) expr -> expr MINUS expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 19 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 19 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 19 (expr -> expr MINUS expr .)
    AND_ALSO        reduce using rule 19 (expr -> expr MINUS expr .)
    OR_ELSE         reduce using rule 19 (expr -> expr MINUS expr .)
    LTE             reduce using rule 19 (expr -> expr MINUS expr .)
    GTE             reduce using rule 19 (expr -> expr MINUS expr .)
    EQ_EQ           reduce using rule 19 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 19 (expr -> expr MINUS expr .)
    LT              reduce using rule 19 (expr -> expr MINUS expr .)
    GT              reduce using rule 19 (expr -> expr MINUS expr .)
    IN              reduce using rule 19 (expr -> expr MINUS expr .)
    CONS            reduce using rule 19 (expr -> expr MINUS expr .)
    EQ              reduce using rule 19 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 19 (expr -> expr MINUS expr .)
    R_BRACK         reduce using rule 19 (expr -> expr MINUS expr .)
    R_PAREN         reduce using rule 19 (expr -> expr MINUS expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! MULT            [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! DIVINT          [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! L_BRACK         [ reduce using rule 19 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 57

    (21) expr -> expr AND_ALSO expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 21 (expr -> expr AND_ALSO expr .)
    AND_ALSO        reduce using rule 21 (expr -> expr AND_ALSO expr .)
    OR_ELSE         reduce using rule 21 (expr -> expr AND_ALSO expr .)
    EQ              reduce using rule 21 (expr -> expr AND_ALSO expr .)
    COMMA           reduce using rule 21 (expr -> expr AND_ALSO expr .)
    R_BRACK         reduce using rule 21 (expr -> expr AND_ALSO expr .)
    R_PAREN         reduce using rule 21 (expr -> expr AND_ALSO expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! MULT            [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! DIVINT          [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! DIV             [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! MOD             [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! PLUS            [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! MINUS           [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! LTE             [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! GTE             [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! EQ_EQ           [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! NEQ             [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! LT              [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! GT              [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! IN              [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! CONS            [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! L_BRACK         [ reduce using rule 21 (expr -> expr AND_ALSO expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 58

    (22) expr -> expr OR_ELSE expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 22 (expr -> expr OR_ELSE expr .)
    AND_ALSO        reduce using rule 22 (expr -> expr OR_ELSE expr .)
    OR_ELSE         reduce using rule 22 (expr -> expr OR_ELSE expr .)
    EQ              reduce using rule 22 (expr -> expr OR_ELSE expr .)
    COMMA           reduce using rule 22 (expr -> expr OR_ELSE expr .)
    R_BRACK         reduce using rule 22 (expr -> expr OR_ELSE expr .)
    R_PAREN         reduce using rule 22 (expr -> expr OR_ELSE expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! MULT            [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! DIVINT          [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! DIV             [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! MOD             [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! PLUS            [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! MINUS           [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! LTE             [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! GTE             [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! EQ_EQ           [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! NEQ             [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! LT              [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! GT              [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! IN              [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! CONS            [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! L_BRACK         [ reduce using rule 22 (expr -> expr OR_ELSE expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 59

    (23) expr -> expr LTE expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 23 (expr -> expr LTE expr .)
    AND_ALSO        reduce using rule 23 (expr -> expr LTE expr .)
    OR_ELSE         reduce using rule 23 (expr -> expr LTE expr .)
    LTE             reduce using rule 23 (expr -> expr LTE expr .)
    GTE             reduce using rule 23 (expr -> expr LTE expr .)
    EQ_EQ           reduce using rule 23 (expr -> expr LTE expr .)
    NEQ             reduce using rule 23 (expr -> expr LTE expr .)
    LT              reduce using rule 23 (expr -> expr LTE expr .)
    GT              reduce using rule 23 (expr -> expr LTE expr .)
    EQ              reduce using rule 23 (expr -> expr LTE expr .)
    COMMA           reduce using rule 23 (expr -> expr LTE expr .)
    R_BRACK         reduce using rule 23 (expr -> expr LTE expr .)
    R_PAREN         reduce using rule 23 (expr -> expr LTE expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! MULT            [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! DIVINT          [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! DIV             [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! MOD             [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! PLUS            [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! IN              [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! CONS            [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! L_BRACK         [ reduce using rule 23 (expr -> expr LTE expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 60

    (24) expr -> expr GTE expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 24 (expr -> expr GTE expr .)
    AND_ALSO        reduce using rule 24 (expr -> expr GTE expr .)
    OR_ELSE         reduce using rule 24 (expr -> expr GTE expr .)
    LTE             reduce using rule 24 (expr -> expr GTE expr .)
    GTE             reduce using rule 24 (expr -> expr GTE expr .)
    EQ_EQ           reduce using rule 24 (expr -> expr GTE expr .)
    NEQ             reduce using rule 24 (expr -> expr GTE expr .)
    LT              reduce using rule 24 (expr -> expr GTE expr .)
    GT              reduce using rule 24 (expr -> expr GTE expr .)
    EQ              reduce using rule 24 (expr -> expr GTE expr .)
    COMMA           reduce using rule 24 (expr -> expr GTE expr .)
    R_BRACK         reduce using rule 24 (expr -> expr GTE expr .)
    R_PAREN         reduce using rule 24 (expr -> expr GTE expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! MULT            [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! DIVINT          [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! DIV             [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! MOD             [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! PLUS            [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! IN              [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! CONS            [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! L_BRACK         [ reduce using rule 24 (expr -> expr GTE expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 61

    (25) expr -> expr EQ_EQ expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 25 (expr -> expr EQ_EQ expr .)
    AND_ALSO        reduce using rule 25 (expr -> expr EQ_EQ expr .)
    OR_ELSE         reduce using rule 25 (expr -> expr EQ_EQ expr .)
    LTE             reduce using rule 25 (expr -> expr EQ_EQ expr .)
    GTE             reduce using rule 25 (expr -> expr EQ_EQ expr .)
    EQ_EQ           reduce using rule 25 (expr -> expr EQ_EQ expr .)
    NEQ             reduce using rule 25 (expr -> expr EQ_EQ expr .)
    LT              reduce using rule 25 (expr -> expr EQ_EQ expr .)
    GT              reduce using rule 25 (expr -> expr EQ_EQ expr .)
    EQ              reduce using rule 25 (expr -> expr EQ_EQ expr .)
    COMMA           reduce using rule 25 (expr -> expr EQ_EQ expr .)
    R_BRACK         reduce using rule 25 (expr -> expr EQ_EQ expr .)
    R_PAREN         reduce using rule 25 (expr -> expr EQ_EQ expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! MULT            [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! DIVINT          [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! DIV             [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! MOD             [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! PLUS            [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! MINUS           [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! IN              [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! CONS            [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! L_BRACK         [ reduce using rule 25 (expr -> expr EQ_EQ expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 62

    (26) expr -> expr NEQ expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 26 (expr -> expr NEQ expr .)
    AND_ALSO        reduce using rule 26 (expr -> expr NEQ expr .)
    OR_ELSE         reduce using rule 26 (expr -> expr NEQ expr .)
    LTE             reduce using rule 26 (expr -> expr NEQ expr .)
    GTE             reduce using rule 26 (expr -> expr NEQ expr .)
    EQ_EQ           reduce using rule 26 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 26 (expr -> expr NEQ expr .)
    LT              reduce using rule 26 (expr -> expr NEQ expr .)
    GT              reduce using rule 26 (expr -> expr NEQ expr .)
    EQ              reduce using rule 26 (expr -> expr NEQ expr .)
    COMMA           reduce using rule 26 (expr -> expr NEQ expr .)
    R_BRACK         reduce using rule 26 (expr -> expr NEQ expr .)
    R_PAREN         reduce using rule 26 (expr -> expr NEQ expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! MULT            [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! DIVINT          [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! DIV             [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! MOD             [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! PLUS            [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! MINUS           [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! IN              [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! CONS            [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! L_BRACK         [ reduce using rule 26 (expr -> expr NEQ expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 63

    (27) expr -> expr LT expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 27 (expr -> expr LT expr .)
    AND_ALSO        reduce using rule 27 (expr -> expr LT expr .)
    OR_ELSE         reduce using rule 27 (expr -> expr LT expr .)
    LTE             reduce using rule 27 (expr -> expr LT expr .)
    GTE             reduce using rule 27 (expr -> expr LT expr .)
    EQ_EQ           reduce using rule 27 (expr -> expr LT expr .)
    NEQ             reduce using rule 27 (expr -> expr LT expr .)
    LT              reduce using rule 27 (expr -> expr LT expr .)
    GT              reduce using rule 27 (expr -> expr LT expr .)
    EQ              reduce using rule 27 (expr -> expr LT expr .)
    COMMA           reduce using rule 27 (expr -> expr LT expr .)
    R_BRACK         reduce using rule 27 (expr -> expr LT expr .)
    R_PAREN         reduce using rule 27 (expr -> expr LT expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! MULT            [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! DIVINT          [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! IN              [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! CONS            [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! L_BRACK         [ reduce using rule 27 (expr -> expr LT expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 64

    (28) expr -> expr GT expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 28 (expr -> expr GT expr .)
    AND_ALSO        reduce using rule 28 (expr -> expr GT expr .)
    OR_ELSE         reduce using rule 28 (expr -> expr GT expr .)
    LTE             reduce using rule 28 (expr -> expr GT expr .)
    GTE             reduce using rule 28 (expr -> expr GT expr .)
    EQ_EQ           reduce using rule 28 (expr -> expr GT expr .)
    NEQ             reduce using rule 28 (expr -> expr GT expr .)
    LT              reduce using rule 28 (expr -> expr GT expr .)
    GT              reduce using rule 28 (expr -> expr GT expr .)
    EQ              reduce using rule 28 (expr -> expr GT expr .)
    COMMA           reduce using rule 28 (expr -> expr GT expr .)
    R_BRACK         reduce using rule 28 (expr -> expr GT expr .)
    R_PAREN         reduce using rule 28 (expr -> expr GT expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! MULT            [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! DIVINT          [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! IN              [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! CONS            [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! L_BRACK         [ reduce using rule 28 (expr -> expr GT expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 65

    (29) expr -> expr IN expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 29 (expr -> expr IN expr .)
    AND_ALSO        reduce using rule 29 (expr -> expr IN expr .)
    OR_ELSE         reduce using rule 29 (expr -> expr IN expr .)
    LTE             reduce using rule 29 (expr -> expr IN expr .)
    GTE             reduce using rule 29 (expr -> expr IN expr .)
    EQ_EQ           reduce using rule 29 (expr -> expr IN expr .)
    NEQ             reduce using rule 29 (expr -> expr IN expr .)
    LT              reduce using rule 29 (expr -> expr IN expr .)
    GT              reduce using rule 29 (expr -> expr IN expr .)
    IN              reduce using rule 29 (expr -> expr IN expr .)
    CONS            reduce using rule 29 (expr -> expr IN expr .)
    EQ              reduce using rule 29 (expr -> expr IN expr .)
    COMMA           reduce using rule 29 (expr -> expr IN expr .)
    R_BRACK         reduce using rule 29 (expr -> expr IN expr .)
    R_PAREN         reduce using rule 29 (expr -> expr IN expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! MULT            [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! DIVINT          [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! DIV             [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! MOD             [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! PLUS            [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! MINUS           [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! L_BRACK         [ reduce using rule 29 (expr -> expr IN expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 66

    (30) expr -> expr CONS expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 30 (expr -> expr CONS expr .)
    AND_ALSO        reduce using rule 30 (expr -> expr CONS expr .)
    OR_ELSE         reduce using rule 30 (expr -> expr CONS expr .)
    LTE             reduce using rule 30 (expr -> expr CONS expr .)
    GTE             reduce using rule 30 (expr -> expr CONS expr .)
    EQ_EQ           reduce using rule 30 (expr -> expr CONS expr .)
    NEQ             reduce using rule 30 (expr -> expr CONS expr .)
    LT              reduce using rule 30 (expr -> expr CONS expr .)
    GT              reduce using rule 30 (expr -> expr CONS expr .)
    EQ              reduce using rule 30 (expr -> expr CONS expr .)
    COMMA           reduce using rule 30 (expr -> expr CONS expr .)
    R_BRACK         reduce using rule 30 (expr -> expr CONS expr .)
    R_PAREN         reduce using rule 30 (expr -> expr CONS expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35

  ! POW             [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! MULT            [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! DIVINT          [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! DIV             [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! MOD             [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! PLUS            [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! MINUS           [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! IN              [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! CONS            [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! L_BRACK         [ reduce using rule 30 (expr -> expr CONS expr .) ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 67

    (32) expr -> expr L_BRACK expr . R_BRACK
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    R_BRACK         shift and go to state 76
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND_ALSO        shift and go to state 25
    OR_ELSE         shift and go to state 26
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35
    EQ              shift and go to state 17

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 68

    (41) indexTkn -> L_BRACK INTEGER . R_BRACK
    (2) expr -> INTEGER .

  ! shift/reduce conflict for R_BRACK resolved as shift
    R_BRACK         shift and go to state 77
    POW             reduce using rule 2 (expr -> INTEGER .)
    MULT            reduce using rule 2 (expr -> INTEGER .)
    DIVINT          reduce using rule 2 (expr -> INTEGER .)
    DIV             reduce using rule 2 (expr -> INTEGER .)
    MOD             reduce using rule 2 (expr -> INTEGER .)
    PLUS            reduce using rule 2 (expr -> INTEGER .)
    MINUS           reduce using rule 2 (expr -> INTEGER .)
    AND_ALSO        reduce using rule 2 (expr -> INTEGER .)
    OR_ELSE         reduce using rule 2 (expr -> INTEGER .)
    LTE             reduce using rule 2 (expr -> INTEGER .)
    GTE             reduce using rule 2 (expr -> INTEGER .)
    EQ_EQ           reduce using rule 2 (expr -> INTEGER .)
    NEQ             reduce using rule 2 (expr -> INTEGER .)
    LT              reduce using rule 2 (expr -> INTEGER .)
    GT              reduce using rule 2 (expr -> INTEGER .)
    IN              reduce using rule 2 (expr -> INTEGER .)
    CONS            reduce using rule 2 (expr -> INTEGER .)
    L_BRACK         reduce using rule 2 (expr -> INTEGER .)
    EQ              reduce using rule 2 (expr -> INTEGER .)

  ! R_BRACK         [ reduce using rule 2 (expr -> INTEGER .) ]


state 69

    (10) expr -> HASHTAG INTEGER expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

    SEMICOLON       reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    POW             reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    MULT            reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    DIVINT          reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    DIV             reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    MOD             reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    PLUS            reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    MINUS           reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    AND_ALSO        reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    OR_ELSE         reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    LTE             reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    GTE             reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    EQ_EQ           reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    NEQ             reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    LT              reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    GT              reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    IN              reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    CONS            reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    L_BRACK         reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    EQ              reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    COMMA           reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    R_BRACK         reduce using rule 10 (expr -> HASHTAG INTEGER expr .)
    R_PAREN         reduce using rule 10 (expr -> HASHTAG INTEGER expr .)

  ! POW             [ shift and go to state 18 ]
  ! MULT            [ shift and go to state 19 ]
  ! DIVINT          [ shift and go to state 20 ]
  ! DIV             [ shift and go to state 21 ]
  ! MOD             [ shift and go to state 22 ]
  ! PLUS            [ shift and go to state 23 ]
  ! MINUS           [ shift and go to state 24 ]
  ! AND_ALSO        [ shift and go to state 25 ]
  ! OR_ELSE         [ shift and go to state 26 ]
  ! LTE             [ shift and go to state 27 ]
  ! GTE             [ shift and go to state 28 ]
  ! EQ_EQ           [ shift and go to state 29 ]
  ! NEQ             [ shift and go to state 30 ]
  ! LT              [ shift and go to state 31 ]
  ! GT              [ shift and go to state 32 ]
  ! IN              [ shift and go to state 33 ]
  ! CONS            [ shift and go to state 34 ]
  ! L_BRACK         [ shift and go to state 35 ]
  ! EQ              [ shift and go to state 17 ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 70

    (33) list -> L_BRACK sequence R_BRACK .

    SEMICOLON       reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    POW             reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    MULT            reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    DIVINT          reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    DIV             reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    MOD             reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    PLUS            reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    MINUS           reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    AND_ALSO        reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    OR_ELSE         reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    LTE             reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    GTE             reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    EQ_EQ           reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    NEQ             reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    LT              reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    GT              reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    IN              reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    CONS            reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    L_BRACK         reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    EQ              reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    COMMA           reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    R_BRACK         reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)
    R_PAREN         reduce using rule 33 (list -> L_BRACK sequence R_BRACK .)


state 71

    (35) sequence -> expr COMMA . sequence
    (35) sequence -> . expr COMMA sequence
    (36) sequence -> . expr
    (2) expr -> . INTEGER
    (3) expr -> . FLOAT
    (4) expr -> . STRING
    (5) expr -> . BOOLEAN
    (6) expr -> . VARIABLE
    (7) expr -> . list
    (8) expr -> . tuple
    (9) expr -> . expr indexSequenceList EQ expr
    (10) expr -> . HASHTAG INTEGER expr
    (13) expr -> . expr POW expr
    (14) expr -> . expr MULT expr
    (15) expr -> . expr DIVINT expr
    (16) expr -> . expr DIV expr
    (17) expr -> . expr MOD expr
    (18) expr -> . expr PLUS expr
    (19) expr -> . expr MINUS expr
    (20) expr -> . MINUS expr
    (21) expr -> . expr AND_ALSO expr
    (22) expr -> . expr OR_ELSE expr
    (23) expr -> . expr LTE expr
    (24) expr -> . expr GTE expr
    (25) expr -> . expr EQ_EQ expr
    (26) expr -> . expr NEQ expr
    (27) expr -> . expr LT expr
    (28) expr -> . expr GT expr
    (29) expr -> . expr IN expr
    (30) expr -> . expr CONS expr
    (31) expr -> . NOT expr
    (32) expr -> . expr L_BRACK expr R_BRACK
    (37) expr -> . L_PAREN expr R_PAREN
    (38) expr -> . expr EQ expr
    (33) list -> . L_BRACK sequence R_BRACK
    (34) list -> . L_BRACK R_BRACK
    (11) tuple -> . L_PAREN sequence R_PAREN
    (12) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 3
    FLOAT           shift and go to state 4
    STRING          shift and go to state 5
    BOOLEAN         shift and go to state 6
    VARIABLE        shift and go to state 7
    HASHTAG         shift and go to state 10
    MINUS           shift and go to state 11
    NOT             shift and go to state 12
    L_PAREN         shift and go to state 14
    L_BRACK         shift and go to state 13

    expr                           shift and go to state 42
    sequence                       shift and go to state 78
    list                           shift and go to state 8
    tuple                          shift and go to state 9

state 72

    (37) expr -> L_PAREN expr R_PAREN .

    SEMICOLON       reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    POW             reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    MULT            reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    DIVINT          reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    DIV             reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    AND_ALSO        reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    OR_ELSE         reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    LTE             reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    GTE             reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    EQ_EQ           reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    NEQ             reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    IN              reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    CONS            reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    L_BRACK         reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    R_BRACK         reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 37 (expr -> L_PAREN expr R_PAREN .)


state 73

    (11) tuple -> L_PAREN sequence R_PAREN .

    SEMICOLON       reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    POW             reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    MULT            reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    DIVINT          reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    DIV             reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    MOD             reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    PLUS            reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    MINUS           reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    AND_ALSO        reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    OR_ELSE         reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    LTE             reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    GTE             reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    EQ_EQ           reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    NEQ             reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    LT              reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    GT              reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    IN              reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    CONS            reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    L_BRACK         reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    EQ              reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    COMMA           reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    R_BRACK         reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)
    R_PAREN         reduce using rule 11 (tuple -> L_PAREN sequence R_PAREN .)


state 74

    (9) expr -> expr indexSequenceList EQ expr .
    (9) expr -> expr . indexSequenceList EQ expr
    (13) expr -> expr . POW expr
    (14) expr -> expr . MULT expr
    (15) expr -> expr . DIVINT expr
    (16) expr -> expr . DIV expr
    (17) expr -> expr . MOD expr
    (18) expr -> expr . PLUS expr
    (19) expr -> expr . MINUS expr
    (21) expr -> expr . AND_ALSO expr
    (22) expr -> expr . OR_ELSE expr
    (23) expr -> expr . LTE expr
    (24) expr -> expr . GTE expr
    (25) expr -> expr . EQ_EQ expr
    (26) expr -> expr . NEQ expr
    (27) expr -> expr . LT expr
    (28) expr -> expr . GT expr
    (29) expr -> expr . IN expr
    (30) expr -> expr . CONS expr
    (32) expr -> expr . L_BRACK expr R_BRACK
    (38) expr -> expr . EQ expr
    (39) indexSequenceList -> . indexSequenceList indexTkn
    (40) indexSequenceList -> . indexTkn
    (41) indexTkn -> . L_BRACK INTEGER R_BRACK

  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVINT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND_ALSO resolved as shift
  ! shift/reduce conflict for OR_ELSE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for IN resolved as shift
  ! shift/reduce conflict for CONS resolved as shift
  ! shift/reduce conflict for L_BRACK resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
    SEMICOLON       reduce using rule 9 (expr -> expr indexSequenceList EQ expr .)
    COMMA           reduce using rule 9 (expr -> expr indexSequenceList EQ expr .)
    R_BRACK         reduce using rule 9 (expr -> expr indexSequenceList EQ expr .)
    R_PAREN         reduce using rule 9 (expr -> expr indexSequenceList EQ expr .)
    POW             shift and go to state 18
    MULT            shift and go to state 19
    DIVINT          shift and go to state 20
    DIV             shift and go to state 21
    MOD             shift and go to state 22
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND_ALSO        shift and go to state 25
    OR_ELSE         shift and go to state 26
    LTE             shift and go to state 27
    GTE             shift and go to state 28
    EQ_EQ           shift and go to state 29
    NEQ             shift and go to state 30
    LT              shift and go to state 31
    GT              shift and go to state 32
    IN              shift and go to state 33
    CONS            shift and go to state 34
    L_BRACK         shift and go to state 35
    EQ              shift and go to state 17

  ! POW             [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! MULT            [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! DIVINT          [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! DIV             [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! MOD             [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! PLUS            [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! MINUS           [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! AND_ALSO        [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! OR_ELSE         [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! LTE             [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! GTE             [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! NEQ             [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! LT              [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! GT              [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! IN              [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! CONS            [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! L_BRACK         [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]
  ! EQ              [ reduce using rule 9 (expr -> expr indexSequenceList EQ expr .) ]

    indexSequenceList              shift and go to state 16
    indexTkn                       shift and go to state 36

state 75

    (41) indexTkn -> L_BRACK INTEGER . R_BRACK

    R_BRACK         shift and go to state 77


state 76

    (32) expr -> expr L_BRACK expr R_BRACK .

    SEMICOLON       reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    POW             reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    MULT            reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    DIVINT          reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    DIV             reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    MOD             reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    PLUS            reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    MINUS           reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    AND_ALSO        reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    OR_ELSE         reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    LTE             reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    GTE             reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    EQ_EQ           reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    NEQ             reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    LT              reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    GT              reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    IN              reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    CONS            reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    EQ              reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    COMMA           reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    R_BRACK         reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)
    R_PAREN         reduce using rule 32 (expr -> expr L_BRACK expr R_BRACK .)


state 77

    (41) indexTkn -> L_BRACK INTEGER R_BRACK .

    EQ              reduce using rule 41 (indexTkn -> L_BRACK INTEGER R_BRACK .)
    L_BRACK         reduce using rule 41 (indexTkn -> L_BRACK INTEGER R_BRACK .)


state 78

    (35) sequence -> expr COMMA sequence .

    R_BRACK         reduce using rule 35 (sequence -> expr COMMA sequence .)
    R_PAREN         reduce using rule 35 (sequence -> expr COMMA sequence .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for R_PAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for POW in state 49 resolved as shift
WARNING: shift/reduce conflict for MULT in state 49 resolved as shift
WARNING: shift/reduce conflict for DIVINT in state 49 resolved as shift
WARNING: shift/reduce conflict for DIV in state 49 resolved as shift
WARNING: shift/reduce conflict for MOD in state 49 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 49 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 49 resolved as shift
WARNING: shift/reduce conflict for AND_ALSO in state 49 resolved as shift
WARNING: shift/reduce conflict for OR_ELSE in state 49 resolved as shift
WARNING: shift/reduce conflict for LTE in state 49 resolved as shift
WARNING: shift/reduce conflict for GTE in state 49 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 49 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 49 resolved as shift
WARNING: shift/reduce conflict for LT in state 49 resolved as shift
WARNING: shift/reduce conflict for GT in state 49 resolved as shift
WARNING: shift/reduce conflict for IN in state 49 resolved as shift
WARNING: shift/reduce conflict for CONS in state 49 resolved as shift
WARNING: shift/reduce conflict for L_BRACK in state 49 resolved as shift
WARNING: shift/reduce conflict for EQ in state 49 resolved as shift
WARNING: shift/reduce conflict for R_BRACK in state 68 resolved as shift
WARNING: shift/reduce conflict for POW in state 74 resolved as shift
WARNING: shift/reduce conflict for MULT in state 74 resolved as shift
WARNING: shift/reduce conflict for DIVINT in state 74 resolved as shift
WARNING: shift/reduce conflict for DIV in state 74 resolved as shift
WARNING: shift/reduce conflict for MOD in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for AND_ALSO in state 74 resolved as shift
WARNING: shift/reduce conflict for OR_ELSE in state 74 resolved as shift
WARNING: shift/reduce conflict for LTE in state 74 resolved as shift
WARNING: shift/reduce conflict for GTE in state 74 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 74 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 74 resolved as shift
WARNING: shift/reduce conflict for LT in state 74 resolved as shift
WARNING: shift/reduce conflict for GT in state 74 resolved as shift
WARNING: shift/reduce conflict for IN in state 74 resolved as shift
WARNING: shift/reduce conflict for CONS in state 74 resolved as shift
WARNING: shift/reduce conflict for L_BRACK in state 74 resolved as shift
WARNING: shift/reduce conflict for EQ in state 74 resolved as shift
