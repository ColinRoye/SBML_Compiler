Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON

Grammar

Rule 0     S' -> program
Rule 1     program -> fun_list block
Rule 2     program -> block
Rule 3     fun_list -> fun_list fun_assignment
Rule 4     fun_list -> fun_assignment
Rule 5     block_list -> block_list stmt_list
Rule 6     block_list -> stmt_list
Rule 7     block_list -> block_list block
Rule 8     block_list -> block
Rule 9     cond_stmt -> if
Rule 10    cond_stmt -> if_else
Rule 11    cond_stmt -> while
Rule 12    stmt_list -> stmt_list stmt
Rule 13    stmt_list -> stmt
Rule 14    block -> LC block_list RC
Rule 15    block -> LC RC
Rule 16    print -> PRINT L_PAREN expr R_PAREN
Rule 17    stmt -> expr SEMICOLON
Rule 18    stmt -> print SEMICOLON
Rule 19    stmt -> assignment SEMICOLON
Rule 20    stmt -> cond_stmt
Rule 21    stmt -> fun_assignment
Rule 22    if_else -> IF L_PAREN expr R_PAREN block ELSE block
Rule 23    if -> IF L_PAREN expr R_PAREN block
Rule 24    while -> WHILE L_PAREN expr R_PAREN block
Rule 25    expr -> INTEGER
Rule 26    expr -> FLOAT
Rule 27    expr -> STRING
Rule 28    expr -> BOOLEAN
Rule 29    expr -> fun_call
Rule 30    expr -> VARIABLE
Rule 31    expr -> list
Rule 32    expr -> tuple
Rule 33    fun_call -> VARIABLE L_PAREN sequence R_PAREN
Rule 34    fun_call -> VARIABLE L_PAREN R_PAREN
Rule 35    fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
Rule 36    fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON
Rule 37    assignment -> expr indexSequenceList EQ expr
Rule 38    assignment -> expr EQ expr
Rule 39    expr -> HASHTAG INTEGER expr
Rule 40    tuple -> L_PAREN sequence R_PAREN
Rule 41    tuple -> L_PAREN R_PAREN
Rule 42    expr -> expr POW expr
Rule 43    expr -> expr MULT expr
Rule 44    expr -> expr DIVINT expr
Rule 45    expr -> expr DIV expr
Rule 46    expr -> expr MOD expr
Rule 47    expr -> expr PLUS expr
Rule 48    expr -> expr MINUS expr
Rule 49    expr -> MINUS expr
Rule 50    expr -> expr AND_ALSO expr
Rule 51    expr -> expr OR_ELSE expr
Rule 52    expr -> expr LTE expr
Rule 53    expr -> expr GTE expr
Rule 54    expr -> expr EQ_EQ expr
Rule 55    expr -> expr NEQ expr
Rule 56    expr -> expr LT expr
Rule 57    expr -> expr GT expr
Rule 58    expr -> expr IN expr
Rule 59    expr -> expr CONS expr
Rule 60    expr -> NOT expr
Rule 61    indexSequenceList -> indexSequenceList indexTkn
Rule 62    indexSequenceList -> indexTkn
Rule 63    indexTkn -> L_BRACK expr R_BRACK
Rule 64    expr -> expr L_BRACK expr R_BRACK
Rule 65    list -> L_BRACK sequence R_BRACK
Rule 66    list -> L_BRACK R_BRACK
Rule 67    sequence -> expr COMMA sequence
Rule 68    sequence -> expr
Rule 69    expr -> L_PAREN expr R_PAREN

Terminals, with rules where they appear

AND_ALSO             : 50
BOOLEAN              : 28
COLON                : 
COMMA                : 67
CONS                 : 59
DIV                  : 45
DIVINT               : 44
ELSE                 : 22
EQ                   : 35 36 37 38
EQ_EQ                : 54
FLOAT                : 26
FUN                  : 35 36
GT                   : 57
GTE                  : 53
HASHTAG              : 39
IF                   : 22 23
IN                   : 58
INTEGER              : 25 39
LC                   : 14 15
LT                   : 56
LTE                  : 52
L_BRACK              : 63 64 65 66
L_PAREN              : 16 22 23 24 33 34 35 36 40 41 69
MINUS                : 48 49
MOD                  : 46
MULT                 : 43
NEQ                  : 55
NOT                  : 60
OR_ELSE              : 51
PLUS                 : 47
POW                  : 42
PRINT                : 16
RC                   : 14 15
R_BRACK              : 63 64 65 66
R_PAREN              : 16 22 23 24 33 34 35 36 40 41 69
SEMICOLON            : 17 18 19 35 36
STRING               : 27
VARIABLE             : 30 33 34 35 36
WHILE                : 24
error                : 

Nonterminals, with rules where they appear

assignment           : 19
block                : 1 2 7 8 22 22 23 24 35 36
block_list           : 5 7 14
cond_stmt            : 20
expr                 : 16 17 22 23 24 35 36 37 37 38 38 39 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 63 64 64 67 68 69
fun_assignment       : 3 4 21
fun_call             : 29
fun_list             : 1 3
if                   : 9
if_else              : 10
indexSequenceList    : 37 61
indexTkn             : 61 62
list                 : 31
print                : 18
program              : 0
sequence             : 33 35 40 65 67
stmt                 : 12 13
stmt_list            : 5 6 12
tuple                : 32
while                : 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . fun_list block
    (2) program -> . block
    (3) fun_list -> . fun_list fun_assignment
    (4) fun_list -> . fun_assignment
    (14) block -> . LC block_list RC
    (15) block -> . LC RC
    (35) fun_assignment -> . FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> . FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON

    LC              shift and go to state 5
    FUN             shift and go to state 6

    program                        shift and go to state 1
    fun_list                       shift and go to state 2
    block                          shift and go to state 3
    fun_assignment                 shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> fun_list . block
    (3) fun_list -> fun_list . fun_assignment
    (14) block -> . LC block_list RC
    (15) block -> . LC RC
    (35) fun_assignment -> . FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> . FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON

    LC              shift and go to state 5
    FUN             shift and go to state 6

    block                          shift and go to state 7
    fun_assignment                 shift and go to state 8

state 3

    (2) program -> block .

    $end            reduce using rule 2 (program -> block .)


state 4

    (4) fun_list -> fun_assignment .

    LC              reduce using rule 4 (fun_list -> fun_assignment .)
    FUN             reduce using rule 4 (fun_list -> fun_assignment .)


state 5

    (14) block -> LC . block_list RC
    (15) block -> LC . RC
    (5) block_list -> . block_list stmt_list
    (6) block_list -> . stmt_list
    (7) block_list -> . block_list block
    (8) block_list -> . block
    (12) stmt_list -> . stmt_list stmt
    (13) stmt_list -> . stmt
    (14) block -> . LC block_list RC
    (15) block -> . LC RC
    (17) stmt -> . expr SEMICOLON
    (18) stmt -> . print SEMICOLON
    (19) stmt -> . assignment SEMICOLON
    (20) stmt -> . cond_stmt
    (21) stmt -> . fun_assignment
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (16) print -> . PRINT L_PAREN expr R_PAREN
    (37) assignment -> . expr indexSequenceList EQ expr
    (38) assignment -> . expr EQ expr
    (9) cond_stmt -> . if
    (10) cond_stmt -> . if_else
    (11) cond_stmt -> . while
    (35) fun_assignment -> . FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> . FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN
    (23) if -> . IF L_PAREN expr R_PAREN block
    (22) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (24) while -> . WHILE L_PAREN expr R_PAREN block

    RC              shift and go to state 10
    LC              shift and go to state 5
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    PRINT           shift and go to state 32
    FUN             shift and go to state 6
    L_BRACK         shift and go to state 30
    IF              shift and go to state 36
    WHILE           shift and go to state 37

    block_list                     shift and go to state 9
    stmt_list                      shift and go to state 11
    block                          shift and go to state 12
    stmt                           shift and go to state 13
    expr                           shift and go to state 14
    print                          shift and go to state 15
    assignment                     shift and go to state 16
    cond_stmt                      shift and go to state 17
    fun_assignment                 shift and go to state 18
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26
    if                             shift and go to state 33
    if_else                        shift and go to state 34
    while                          shift and go to state 35

state 6

    (35) fun_assignment -> FUN . VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> FUN . VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON

    VARIABLE        shift and go to state 38


state 7

    (1) program -> fun_list block .

    $end            reduce using rule 1 (program -> fun_list block .)


state 8

    (3) fun_list -> fun_list fun_assignment .

    LC              reduce using rule 3 (fun_list -> fun_list fun_assignment .)
    FUN             reduce using rule 3 (fun_list -> fun_list fun_assignment .)


state 9

    (14) block -> LC block_list . RC
    (5) block_list -> block_list . stmt_list
    (7) block_list -> block_list . block
    (12) stmt_list -> . stmt_list stmt
    (13) stmt_list -> . stmt
    (14) block -> . LC block_list RC
    (15) block -> . LC RC
    (17) stmt -> . expr SEMICOLON
    (18) stmt -> . print SEMICOLON
    (19) stmt -> . assignment SEMICOLON
    (20) stmt -> . cond_stmt
    (21) stmt -> . fun_assignment
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (16) print -> . PRINT L_PAREN expr R_PAREN
    (37) assignment -> . expr indexSequenceList EQ expr
    (38) assignment -> . expr EQ expr
    (9) cond_stmt -> . if
    (10) cond_stmt -> . if_else
    (11) cond_stmt -> . while
    (35) fun_assignment -> . FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> . FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN
    (23) if -> . IF L_PAREN expr R_PAREN block
    (22) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (24) while -> . WHILE L_PAREN expr R_PAREN block

    RC              shift and go to state 39
    LC              shift and go to state 5
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    PRINT           shift and go to state 32
    FUN             shift and go to state 6
    L_BRACK         shift and go to state 30
    IF              shift and go to state 36
    WHILE           shift and go to state 37

    stmt_list                      shift and go to state 40
    block                          shift and go to state 41
    stmt                           shift and go to state 13
    expr                           shift and go to state 14
    print                          shift and go to state 15
    assignment                     shift and go to state 16
    cond_stmt                      shift and go to state 17
    fun_assignment                 shift and go to state 18
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26
    if                             shift and go to state 33
    if_else                        shift and go to state 34
    while                          shift and go to state 35

state 10

    (15) block -> LC RC .

    $end            reduce using rule 15 (block -> LC RC .)
    RC              reduce using rule 15 (block -> LC RC .)
    LC              reduce using rule 15 (block -> LC RC .)
    INTEGER         reduce using rule 15 (block -> LC RC .)
    FLOAT           reduce using rule 15 (block -> LC RC .)
    STRING          reduce using rule 15 (block -> LC RC .)
    BOOLEAN         reduce using rule 15 (block -> LC RC .)
    VARIABLE        reduce using rule 15 (block -> LC RC .)
    HASHTAG         reduce using rule 15 (block -> LC RC .)
    MINUS           reduce using rule 15 (block -> LC RC .)
    NOT             reduce using rule 15 (block -> LC RC .)
    L_PAREN         reduce using rule 15 (block -> LC RC .)
    PRINT           reduce using rule 15 (block -> LC RC .)
    FUN             reduce using rule 15 (block -> LC RC .)
    L_BRACK         reduce using rule 15 (block -> LC RC .)
    IF              reduce using rule 15 (block -> LC RC .)
    WHILE           reduce using rule 15 (block -> LC RC .)
    ELSE            reduce using rule 15 (block -> LC RC .)


state 11

    (6) block_list -> stmt_list .
    (12) stmt_list -> stmt_list . stmt
    (17) stmt -> . expr SEMICOLON
    (18) stmt -> . print SEMICOLON
    (19) stmt -> . assignment SEMICOLON
    (20) stmt -> . cond_stmt
    (21) stmt -> . fun_assignment
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (16) print -> . PRINT L_PAREN expr R_PAREN
    (37) assignment -> . expr indexSequenceList EQ expr
    (38) assignment -> . expr EQ expr
    (9) cond_stmt -> . if
    (10) cond_stmt -> . if_else
    (11) cond_stmt -> . while
    (35) fun_assignment -> . FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> . FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN
    (23) if -> . IF L_PAREN expr R_PAREN block
    (22) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (24) while -> . WHILE L_PAREN expr R_PAREN block

  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for HASHTAG resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for L_BRACK resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    RC              reduce using rule 6 (block_list -> stmt_list .)
    LC              reduce using rule 6 (block_list -> stmt_list .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    PRINT           shift and go to state 32
    FUN             shift and go to state 6
    L_BRACK         shift and go to state 30
    IF              shift and go to state 36
    WHILE           shift and go to state 37

  ! INTEGER         [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! FLOAT           [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! STRING          [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! BOOLEAN         [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! VARIABLE        [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! HASHTAG         [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! MINUS           [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! NOT             [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! L_PAREN         [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! PRINT           [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! FUN             [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! L_BRACK         [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! IF              [ reduce using rule 6 (block_list -> stmt_list .) ]
  ! WHILE           [ reduce using rule 6 (block_list -> stmt_list .) ]

    stmt                           shift and go to state 42
    expr                           shift and go to state 14
    print                          shift and go to state 15
    assignment                     shift and go to state 16
    cond_stmt                      shift and go to state 17
    fun_assignment                 shift and go to state 18
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26
    if                             shift and go to state 33
    if_else                        shift and go to state 34
    while                          shift and go to state 35

state 12

    (8) block_list -> block .

    RC              reduce using rule 8 (block_list -> block .)
    LC              reduce using rule 8 (block_list -> block .)
    INTEGER         reduce using rule 8 (block_list -> block .)
    FLOAT           reduce using rule 8 (block_list -> block .)
    STRING          reduce using rule 8 (block_list -> block .)
    BOOLEAN         reduce using rule 8 (block_list -> block .)
    VARIABLE        reduce using rule 8 (block_list -> block .)
    HASHTAG         reduce using rule 8 (block_list -> block .)
    MINUS           reduce using rule 8 (block_list -> block .)
    NOT             reduce using rule 8 (block_list -> block .)
    L_PAREN         reduce using rule 8 (block_list -> block .)
    PRINT           reduce using rule 8 (block_list -> block .)
    FUN             reduce using rule 8 (block_list -> block .)
    L_BRACK         reduce using rule 8 (block_list -> block .)
    IF              reduce using rule 8 (block_list -> block .)
    WHILE           reduce using rule 8 (block_list -> block .)


state 13

    (13) stmt_list -> stmt .

    INTEGER         reduce using rule 13 (stmt_list -> stmt .)
    FLOAT           reduce using rule 13 (stmt_list -> stmt .)
    STRING          reduce using rule 13 (stmt_list -> stmt .)
    BOOLEAN         reduce using rule 13 (stmt_list -> stmt .)
    VARIABLE        reduce using rule 13 (stmt_list -> stmt .)
    HASHTAG         reduce using rule 13 (stmt_list -> stmt .)
    MINUS           reduce using rule 13 (stmt_list -> stmt .)
    NOT             reduce using rule 13 (stmt_list -> stmt .)
    L_PAREN         reduce using rule 13 (stmt_list -> stmt .)
    PRINT           reduce using rule 13 (stmt_list -> stmt .)
    FUN             reduce using rule 13 (stmt_list -> stmt .)
    L_BRACK         reduce using rule 13 (stmt_list -> stmt .)
    IF              reduce using rule 13 (stmt_list -> stmt .)
    WHILE           reduce using rule 13 (stmt_list -> stmt .)
    RC              reduce using rule 13 (stmt_list -> stmt .)
    LC              reduce using rule 13 (stmt_list -> stmt .)


state 14

    (17) stmt -> expr . SEMICOLON
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK
    (37) assignment -> expr . indexSequenceList EQ expr
    (38) assignment -> expr . EQ expr
    (61) indexSequenceList -> . indexSequenceList indexTkn
    (62) indexSequenceList -> . indexTkn
    (63) indexTkn -> . L_BRACK expr R_BRACK

    SEMICOLON       shift and go to state 43
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 61
    EQ              shift and go to state 63

    indexSequenceList              shift and go to state 62
    indexTkn                       shift and go to state 64

state 15

    (18) stmt -> print . SEMICOLON

    SEMICOLON       shift and go to state 65


state 16

    (19) stmt -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 66


state 17

    (20) stmt -> cond_stmt .

    INTEGER         reduce using rule 20 (stmt -> cond_stmt .)
    FLOAT           reduce using rule 20 (stmt -> cond_stmt .)
    STRING          reduce using rule 20 (stmt -> cond_stmt .)
    BOOLEAN         reduce using rule 20 (stmt -> cond_stmt .)
    VARIABLE        reduce using rule 20 (stmt -> cond_stmt .)
    HASHTAG         reduce using rule 20 (stmt -> cond_stmt .)
    MINUS           reduce using rule 20 (stmt -> cond_stmt .)
    NOT             reduce using rule 20 (stmt -> cond_stmt .)
    L_PAREN         reduce using rule 20 (stmt -> cond_stmt .)
    PRINT           reduce using rule 20 (stmt -> cond_stmt .)
    FUN             reduce using rule 20 (stmt -> cond_stmt .)
    L_BRACK         reduce using rule 20 (stmt -> cond_stmt .)
    IF              reduce using rule 20 (stmt -> cond_stmt .)
    WHILE           reduce using rule 20 (stmt -> cond_stmt .)
    RC              reduce using rule 20 (stmt -> cond_stmt .)
    LC              reduce using rule 20 (stmt -> cond_stmt .)


state 18

    (21) stmt -> fun_assignment .

    INTEGER         reduce using rule 21 (stmt -> fun_assignment .)
    FLOAT           reduce using rule 21 (stmt -> fun_assignment .)
    STRING          reduce using rule 21 (stmt -> fun_assignment .)
    BOOLEAN         reduce using rule 21 (stmt -> fun_assignment .)
    VARIABLE        reduce using rule 21 (stmt -> fun_assignment .)
    HASHTAG         reduce using rule 21 (stmt -> fun_assignment .)
    MINUS           reduce using rule 21 (stmt -> fun_assignment .)
    NOT             reduce using rule 21 (stmt -> fun_assignment .)
    L_PAREN         reduce using rule 21 (stmt -> fun_assignment .)
    PRINT           reduce using rule 21 (stmt -> fun_assignment .)
    FUN             reduce using rule 21 (stmt -> fun_assignment .)
    L_BRACK         reduce using rule 21 (stmt -> fun_assignment .)
    IF              reduce using rule 21 (stmt -> fun_assignment .)
    WHILE           reduce using rule 21 (stmt -> fun_assignment .)
    RC              reduce using rule 21 (stmt -> fun_assignment .)
    LC              reduce using rule 21 (stmt -> fun_assignment .)


state 19

    (25) expr -> INTEGER .

    SEMICOLON       reduce using rule 25 (expr -> INTEGER .)
    POW             reduce using rule 25 (expr -> INTEGER .)
    MULT            reduce using rule 25 (expr -> INTEGER .)
    DIVINT          reduce using rule 25 (expr -> INTEGER .)
    DIV             reduce using rule 25 (expr -> INTEGER .)
    MOD             reduce using rule 25 (expr -> INTEGER .)
    PLUS            reduce using rule 25 (expr -> INTEGER .)
    MINUS           reduce using rule 25 (expr -> INTEGER .)
    AND_ALSO        reduce using rule 25 (expr -> INTEGER .)
    OR_ELSE         reduce using rule 25 (expr -> INTEGER .)
    LTE             reduce using rule 25 (expr -> INTEGER .)
    GTE             reduce using rule 25 (expr -> INTEGER .)
    EQ_EQ           reduce using rule 25 (expr -> INTEGER .)
    NEQ             reduce using rule 25 (expr -> INTEGER .)
    LT              reduce using rule 25 (expr -> INTEGER .)
    GT              reduce using rule 25 (expr -> INTEGER .)
    IN              reduce using rule 25 (expr -> INTEGER .)
    CONS            reduce using rule 25 (expr -> INTEGER .)
    L_BRACK         reduce using rule 25 (expr -> INTEGER .)
    EQ              reduce using rule 25 (expr -> INTEGER .)
    COMMA           reduce using rule 25 (expr -> INTEGER .)
    R_BRACK         reduce using rule 25 (expr -> INTEGER .)
    R_PAREN         reduce using rule 25 (expr -> INTEGER .)


state 20

    (26) expr -> FLOAT .

    SEMICOLON       reduce using rule 26 (expr -> FLOAT .)
    POW             reduce using rule 26 (expr -> FLOAT .)
    MULT            reduce using rule 26 (expr -> FLOAT .)
    DIVINT          reduce using rule 26 (expr -> FLOAT .)
    DIV             reduce using rule 26 (expr -> FLOAT .)
    MOD             reduce using rule 26 (expr -> FLOAT .)
    PLUS            reduce using rule 26 (expr -> FLOAT .)
    MINUS           reduce using rule 26 (expr -> FLOAT .)
    AND_ALSO        reduce using rule 26 (expr -> FLOAT .)
    OR_ELSE         reduce using rule 26 (expr -> FLOAT .)
    LTE             reduce using rule 26 (expr -> FLOAT .)
    GTE             reduce using rule 26 (expr -> FLOAT .)
    EQ_EQ           reduce using rule 26 (expr -> FLOAT .)
    NEQ             reduce using rule 26 (expr -> FLOAT .)
    LT              reduce using rule 26 (expr -> FLOAT .)
    GT              reduce using rule 26 (expr -> FLOAT .)
    IN              reduce using rule 26 (expr -> FLOAT .)
    CONS            reduce using rule 26 (expr -> FLOAT .)
    L_BRACK         reduce using rule 26 (expr -> FLOAT .)
    EQ              reduce using rule 26 (expr -> FLOAT .)
    COMMA           reduce using rule 26 (expr -> FLOAT .)
    R_BRACK         reduce using rule 26 (expr -> FLOAT .)
    R_PAREN         reduce using rule 26 (expr -> FLOAT .)


state 21

    (27) expr -> STRING .

    SEMICOLON       reduce using rule 27 (expr -> STRING .)
    POW             reduce using rule 27 (expr -> STRING .)
    MULT            reduce using rule 27 (expr -> STRING .)
    DIVINT          reduce using rule 27 (expr -> STRING .)
    DIV             reduce using rule 27 (expr -> STRING .)
    MOD             reduce using rule 27 (expr -> STRING .)
    PLUS            reduce using rule 27 (expr -> STRING .)
    MINUS           reduce using rule 27 (expr -> STRING .)
    AND_ALSO        reduce using rule 27 (expr -> STRING .)
    OR_ELSE         reduce using rule 27 (expr -> STRING .)
    LTE             reduce using rule 27 (expr -> STRING .)
    GTE             reduce using rule 27 (expr -> STRING .)
    EQ_EQ           reduce using rule 27 (expr -> STRING .)
    NEQ             reduce using rule 27 (expr -> STRING .)
    LT              reduce using rule 27 (expr -> STRING .)
    GT              reduce using rule 27 (expr -> STRING .)
    IN              reduce using rule 27 (expr -> STRING .)
    CONS            reduce using rule 27 (expr -> STRING .)
    L_BRACK         reduce using rule 27 (expr -> STRING .)
    EQ              reduce using rule 27 (expr -> STRING .)
    COMMA           reduce using rule 27 (expr -> STRING .)
    R_BRACK         reduce using rule 27 (expr -> STRING .)
    R_PAREN         reduce using rule 27 (expr -> STRING .)


state 22

    (28) expr -> BOOLEAN .

    SEMICOLON       reduce using rule 28 (expr -> BOOLEAN .)
    POW             reduce using rule 28 (expr -> BOOLEAN .)
    MULT            reduce using rule 28 (expr -> BOOLEAN .)
    DIVINT          reduce using rule 28 (expr -> BOOLEAN .)
    DIV             reduce using rule 28 (expr -> BOOLEAN .)
    MOD             reduce using rule 28 (expr -> BOOLEAN .)
    PLUS            reduce using rule 28 (expr -> BOOLEAN .)
    MINUS           reduce using rule 28 (expr -> BOOLEAN .)
    AND_ALSO        reduce using rule 28 (expr -> BOOLEAN .)
    OR_ELSE         reduce using rule 28 (expr -> BOOLEAN .)
    LTE             reduce using rule 28 (expr -> BOOLEAN .)
    GTE             reduce using rule 28 (expr -> BOOLEAN .)
    EQ_EQ           reduce using rule 28 (expr -> BOOLEAN .)
    NEQ             reduce using rule 28 (expr -> BOOLEAN .)
    LT              reduce using rule 28 (expr -> BOOLEAN .)
    GT              reduce using rule 28 (expr -> BOOLEAN .)
    IN              reduce using rule 28 (expr -> BOOLEAN .)
    CONS            reduce using rule 28 (expr -> BOOLEAN .)
    L_BRACK         reduce using rule 28 (expr -> BOOLEAN .)
    EQ              reduce using rule 28 (expr -> BOOLEAN .)
    COMMA           reduce using rule 28 (expr -> BOOLEAN .)
    R_BRACK         reduce using rule 28 (expr -> BOOLEAN .)
    R_PAREN         reduce using rule 28 (expr -> BOOLEAN .)


state 23

    (29) expr -> fun_call .

    SEMICOLON       reduce using rule 29 (expr -> fun_call .)
    POW             reduce using rule 29 (expr -> fun_call .)
    MULT            reduce using rule 29 (expr -> fun_call .)
    DIVINT          reduce using rule 29 (expr -> fun_call .)
    DIV             reduce using rule 29 (expr -> fun_call .)
    MOD             reduce using rule 29 (expr -> fun_call .)
    PLUS            reduce using rule 29 (expr -> fun_call .)
    MINUS           reduce using rule 29 (expr -> fun_call .)
    AND_ALSO        reduce using rule 29 (expr -> fun_call .)
    OR_ELSE         reduce using rule 29 (expr -> fun_call .)
    LTE             reduce using rule 29 (expr -> fun_call .)
    GTE             reduce using rule 29 (expr -> fun_call .)
    EQ_EQ           reduce using rule 29 (expr -> fun_call .)
    NEQ             reduce using rule 29 (expr -> fun_call .)
    LT              reduce using rule 29 (expr -> fun_call .)
    GT              reduce using rule 29 (expr -> fun_call .)
    IN              reduce using rule 29 (expr -> fun_call .)
    CONS            reduce using rule 29 (expr -> fun_call .)
    L_BRACK         reduce using rule 29 (expr -> fun_call .)
    EQ              reduce using rule 29 (expr -> fun_call .)
    COMMA           reduce using rule 29 (expr -> fun_call .)
    R_BRACK         reduce using rule 29 (expr -> fun_call .)
    R_PAREN         reduce using rule 29 (expr -> fun_call .)


state 24

    (30) expr -> VARIABLE .
    (33) fun_call -> VARIABLE . L_PAREN sequence R_PAREN
    (34) fun_call -> VARIABLE . L_PAREN R_PAREN

    SEMICOLON       reduce using rule 30 (expr -> VARIABLE .)
    POW             reduce using rule 30 (expr -> VARIABLE .)
    MULT            reduce using rule 30 (expr -> VARIABLE .)
    DIVINT          reduce using rule 30 (expr -> VARIABLE .)
    DIV             reduce using rule 30 (expr -> VARIABLE .)
    MOD             reduce using rule 30 (expr -> VARIABLE .)
    PLUS            reduce using rule 30 (expr -> VARIABLE .)
    MINUS           reduce using rule 30 (expr -> VARIABLE .)
    AND_ALSO        reduce using rule 30 (expr -> VARIABLE .)
    OR_ELSE         reduce using rule 30 (expr -> VARIABLE .)
    LTE             reduce using rule 30 (expr -> VARIABLE .)
    GTE             reduce using rule 30 (expr -> VARIABLE .)
    EQ_EQ           reduce using rule 30 (expr -> VARIABLE .)
    NEQ             reduce using rule 30 (expr -> VARIABLE .)
    LT              reduce using rule 30 (expr -> VARIABLE .)
    GT              reduce using rule 30 (expr -> VARIABLE .)
    IN              reduce using rule 30 (expr -> VARIABLE .)
    CONS            reduce using rule 30 (expr -> VARIABLE .)
    L_BRACK         reduce using rule 30 (expr -> VARIABLE .)
    EQ              reduce using rule 30 (expr -> VARIABLE .)
    COMMA           reduce using rule 30 (expr -> VARIABLE .)
    R_BRACK         reduce using rule 30 (expr -> VARIABLE .)
    R_PAREN         reduce using rule 30 (expr -> VARIABLE .)
    L_PAREN         shift and go to state 67


state 25

    (31) expr -> list .

    SEMICOLON       reduce using rule 31 (expr -> list .)
    POW             reduce using rule 31 (expr -> list .)
    MULT            reduce using rule 31 (expr -> list .)
    DIVINT          reduce using rule 31 (expr -> list .)
    DIV             reduce using rule 31 (expr -> list .)
    MOD             reduce using rule 31 (expr -> list .)
    PLUS            reduce using rule 31 (expr -> list .)
    MINUS           reduce using rule 31 (expr -> list .)
    AND_ALSO        reduce using rule 31 (expr -> list .)
    OR_ELSE         reduce using rule 31 (expr -> list .)
    LTE             reduce using rule 31 (expr -> list .)
    GTE             reduce using rule 31 (expr -> list .)
    EQ_EQ           reduce using rule 31 (expr -> list .)
    NEQ             reduce using rule 31 (expr -> list .)
    LT              reduce using rule 31 (expr -> list .)
    GT              reduce using rule 31 (expr -> list .)
    IN              reduce using rule 31 (expr -> list .)
    CONS            reduce using rule 31 (expr -> list .)
    L_BRACK         reduce using rule 31 (expr -> list .)
    EQ              reduce using rule 31 (expr -> list .)
    COMMA           reduce using rule 31 (expr -> list .)
    R_BRACK         reduce using rule 31 (expr -> list .)
    R_PAREN         reduce using rule 31 (expr -> list .)


state 26

    (32) expr -> tuple .

    SEMICOLON       reduce using rule 32 (expr -> tuple .)
    POW             reduce using rule 32 (expr -> tuple .)
    MULT            reduce using rule 32 (expr -> tuple .)
    DIVINT          reduce using rule 32 (expr -> tuple .)
    DIV             reduce using rule 32 (expr -> tuple .)
    MOD             reduce using rule 32 (expr -> tuple .)
    PLUS            reduce using rule 32 (expr -> tuple .)
    MINUS           reduce using rule 32 (expr -> tuple .)
    AND_ALSO        reduce using rule 32 (expr -> tuple .)
    OR_ELSE         reduce using rule 32 (expr -> tuple .)
    LTE             reduce using rule 32 (expr -> tuple .)
    GTE             reduce using rule 32 (expr -> tuple .)
    EQ_EQ           reduce using rule 32 (expr -> tuple .)
    NEQ             reduce using rule 32 (expr -> tuple .)
    LT              reduce using rule 32 (expr -> tuple .)
    GT              reduce using rule 32 (expr -> tuple .)
    IN              reduce using rule 32 (expr -> tuple .)
    CONS            reduce using rule 32 (expr -> tuple .)
    L_BRACK         reduce using rule 32 (expr -> tuple .)
    EQ              reduce using rule 32 (expr -> tuple .)
    COMMA           reduce using rule 32 (expr -> tuple .)
    R_BRACK         reduce using rule 32 (expr -> tuple .)
    R_PAREN         reduce using rule 32 (expr -> tuple .)


state 27

    (39) expr -> HASHTAG . INTEGER expr

    INTEGER         shift and go to state 68


state 28

    (49) expr -> MINUS . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 69
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 29

    (60) expr -> NOT . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 70
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 30

    (65) list -> L_BRACK . sequence R_BRACK
    (66) list -> L_BRACK . R_BRACK
    (67) sequence -> . expr COMMA sequence
    (68) sequence -> . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    R_BRACK         shift and go to state 72
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    sequence                       shift and go to state 71
    expr                           shift and go to state 73
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 31

    (69) expr -> L_PAREN . expr R_PAREN
    (40) tuple -> L_PAREN . sequence R_PAREN
    (41) tuple -> L_PAREN . R_PAREN
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (67) sequence -> . expr COMMA sequence
    (68) sequence -> . expr
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    R_PAREN         shift and go to state 75
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 74
    sequence                       shift and go to state 76
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 32

    (16) print -> PRINT . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 77


state 33

    (9) cond_stmt -> if .

    INTEGER         reduce using rule 9 (cond_stmt -> if .)
    FLOAT           reduce using rule 9 (cond_stmt -> if .)
    STRING          reduce using rule 9 (cond_stmt -> if .)
    BOOLEAN         reduce using rule 9 (cond_stmt -> if .)
    VARIABLE        reduce using rule 9 (cond_stmt -> if .)
    HASHTAG         reduce using rule 9 (cond_stmt -> if .)
    MINUS           reduce using rule 9 (cond_stmt -> if .)
    NOT             reduce using rule 9 (cond_stmt -> if .)
    L_PAREN         reduce using rule 9 (cond_stmt -> if .)
    PRINT           reduce using rule 9 (cond_stmt -> if .)
    FUN             reduce using rule 9 (cond_stmt -> if .)
    L_BRACK         reduce using rule 9 (cond_stmt -> if .)
    IF              reduce using rule 9 (cond_stmt -> if .)
    WHILE           reduce using rule 9 (cond_stmt -> if .)
    RC              reduce using rule 9 (cond_stmt -> if .)
    LC              reduce using rule 9 (cond_stmt -> if .)


state 34

    (10) cond_stmt -> if_else .

    INTEGER         reduce using rule 10 (cond_stmt -> if_else .)
    FLOAT           reduce using rule 10 (cond_stmt -> if_else .)
    STRING          reduce using rule 10 (cond_stmt -> if_else .)
    BOOLEAN         reduce using rule 10 (cond_stmt -> if_else .)
    VARIABLE        reduce using rule 10 (cond_stmt -> if_else .)
    HASHTAG         reduce using rule 10 (cond_stmt -> if_else .)
    MINUS           reduce using rule 10 (cond_stmt -> if_else .)
    NOT             reduce using rule 10 (cond_stmt -> if_else .)
    L_PAREN         reduce using rule 10 (cond_stmt -> if_else .)
    PRINT           reduce using rule 10 (cond_stmt -> if_else .)
    FUN             reduce using rule 10 (cond_stmt -> if_else .)
    L_BRACK         reduce using rule 10 (cond_stmt -> if_else .)
    IF              reduce using rule 10 (cond_stmt -> if_else .)
    WHILE           reduce using rule 10 (cond_stmt -> if_else .)
    RC              reduce using rule 10 (cond_stmt -> if_else .)
    LC              reduce using rule 10 (cond_stmt -> if_else .)


state 35

    (11) cond_stmt -> while .

    INTEGER         reduce using rule 11 (cond_stmt -> while .)
    FLOAT           reduce using rule 11 (cond_stmt -> while .)
    STRING          reduce using rule 11 (cond_stmt -> while .)
    BOOLEAN         reduce using rule 11 (cond_stmt -> while .)
    VARIABLE        reduce using rule 11 (cond_stmt -> while .)
    HASHTAG         reduce using rule 11 (cond_stmt -> while .)
    MINUS           reduce using rule 11 (cond_stmt -> while .)
    NOT             reduce using rule 11 (cond_stmt -> while .)
    L_PAREN         reduce using rule 11 (cond_stmt -> while .)
    PRINT           reduce using rule 11 (cond_stmt -> while .)
    FUN             reduce using rule 11 (cond_stmt -> while .)
    L_BRACK         reduce using rule 11 (cond_stmt -> while .)
    IF              reduce using rule 11 (cond_stmt -> while .)
    WHILE           reduce using rule 11 (cond_stmt -> while .)
    RC              reduce using rule 11 (cond_stmt -> while .)
    LC              reduce using rule 11 (cond_stmt -> while .)


state 36

    (23) if -> IF . L_PAREN expr R_PAREN block
    (22) if_else -> IF . L_PAREN expr R_PAREN block ELSE block

    L_PAREN         shift and go to state 78


state 37

    (24) while -> WHILE . L_PAREN expr R_PAREN block

    L_PAREN         shift and go to state 79


state 38

    (35) fun_assignment -> FUN VARIABLE . L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> FUN VARIABLE . L_PAREN R_PAREN EQ block expr SEMICOLON

    L_PAREN         shift and go to state 80


state 39

    (14) block -> LC block_list RC .

    $end            reduce using rule 14 (block -> LC block_list RC .)
    RC              reduce using rule 14 (block -> LC block_list RC .)
    LC              reduce using rule 14 (block -> LC block_list RC .)
    INTEGER         reduce using rule 14 (block -> LC block_list RC .)
    FLOAT           reduce using rule 14 (block -> LC block_list RC .)
    STRING          reduce using rule 14 (block -> LC block_list RC .)
    BOOLEAN         reduce using rule 14 (block -> LC block_list RC .)
    VARIABLE        reduce using rule 14 (block -> LC block_list RC .)
    HASHTAG         reduce using rule 14 (block -> LC block_list RC .)
    MINUS           reduce using rule 14 (block -> LC block_list RC .)
    NOT             reduce using rule 14 (block -> LC block_list RC .)
    L_PAREN         reduce using rule 14 (block -> LC block_list RC .)
    PRINT           reduce using rule 14 (block -> LC block_list RC .)
    FUN             reduce using rule 14 (block -> LC block_list RC .)
    L_BRACK         reduce using rule 14 (block -> LC block_list RC .)
    IF              reduce using rule 14 (block -> LC block_list RC .)
    WHILE           reduce using rule 14 (block -> LC block_list RC .)
    ELSE            reduce using rule 14 (block -> LC block_list RC .)


state 40

    (5) block_list -> block_list stmt_list .
    (12) stmt_list -> stmt_list . stmt
    (17) stmt -> . expr SEMICOLON
    (18) stmt -> . print SEMICOLON
    (19) stmt -> . assignment SEMICOLON
    (20) stmt -> . cond_stmt
    (21) stmt -> . fun_assignment
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (16) print -> . PRINT L_PAREN expr R_PAREN
    (37) assignment -> . expr indexSequenceList EQ expr
    (38) assignment -> . expr EQ expr
    (9) cond_stmt -> . if
    (10) cond_stmt -> . if_else
    (11) cond_stmt -> . while
    (35) fun_assignment -> . FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> . FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN
    (23) if -> . IF L_PAREN expr R_PAREN block
    (22) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (24) while -> . WHILE L_PAREN expr R_PAREN block

  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for HASHTAG resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for L_BRACK resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    RC              reduce using rule 5 (block_list -> block_list stmt_list .)
    LC              reduce using rule 5 (block_list -> block_list stmt_list .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    PRINT           shift and go to state 32
    FUN             shift and go to state 6
    L_BRACK         shift and go to state 30
    IF              shift and go to state 36
    WHILE           shift and go to state 37

  ! INTEGER         [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! FLOAT           [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! STRING          [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! BOOLEAN         [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! VARIABLE        [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! HASHTAG         [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! MINUS           [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! NOT             [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! L_PAREN         [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! PRINT           [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! FUN             [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! L_BRACK         [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! IF              [ reduce using rule 5 (block_list -> block_list stmt_list .) ]
  ! WHILE           [ reduce using rule 5 (block_list -> block_list stmt_list .) ]

    stmt                           shift and go to state 42
    expr                           shift and go to state 14
    print                          shift and go to state 15
    assignment                     shift and go to state 16
    cond_stmt                      shift and go to state 17
    fun_assignment                 shift and go to state 18
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26
    if                             shift and go to state 33
    if_else                        shift and go to state 34
    while                          shift and go to state 35

state 41

    (7) block_list -> block_list block .

    RC              reduce using rule 7 (block_list -> block_list block .)
    LC              reduce using rule 7 (block_list -> block_list block .)
    INTEGER         reduce using rule 7 (block_list -> block_list block .)
    FLOAT           reduce using rule 7 (block_list -> block_list block .)
    STRING          reduce using rule 7 (block_list -> block_list block .)
    BOOLEAN         reduce using rule 7 (block_list -> block_list block .)
    VARIABLE        reduce using rule 7 (block_list -> block_list block .)
    HASHTAG         reduce using rule 7 (block_list -> block_list block .)
    MINUS           reduce using rule 7 (block_list -> block_list block .)
    NOT             reduce using rule 7 (block_list -> block_list block .)
    L_PAREN         reduce using rule 7 (block_list -> block_list block .)
    PRINT           reduce using rule 7 (block_list -> block_list block .)
    FUN             reduce using rule 7 (block_list -> block_list block .)
    L_BRACK         reduce using rule 7 (block_list -> block_list block .)
    IF              reduce using rule 7 (block_list -> block_list block .)
    WHILE           reduce using rule 7 (block_list -> block_list block .)


state 42

    (12) stmt_list -> stmt_list stmt .

    INTEGER         reduce using rule 12 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 12 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 12 (stmt_list -> stmt_list stmt .)
    BOOLEAN         reduce using rule 12 (stmt_list -> stmt_list stmt .)
    VARIABLE        reduce using rule 12 (stmt_list -> stmt_list stmt .)
    HASHTAG         reduce using rule 12 (stmt_list -> stmt_list stmt .)
    MINUS           reduce using rule 12 (stmt_list -> stmt_list stmt .)
    NOT             reduce using rule 12 (stmt_list -> stmt_list stmt .)
    L_PAREN         reduce using rule 12 (stmt_list -> stmt_list stmt .)
    PRINT           reduce using rule 12 (stmt_list -> stmt_list stmt .)
    FUN             reduce using rule 12 (stmt_list -> stmt_list stmt .)
    L_BRACK         reduce using rule 12 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 12 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 12 (stmt_list -> stmt_list stmt .)
    RC              reduce using rule 12 (stmt_list -> stmt_list stmt .)
    LC              reduce using rule 12 (stmt_list -> stmt_list stmt .)


state 43

    (17) stmt -> expr SEMICOLON .

    INTEGER         reduce using rule 17 (stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 17 (stmt -> expr SEMICOLON .)
    STRING          reduce using rule 17 (stmt -> expr SEMICOLON .)
    BOOLEAN         reduce using rule 17 (stmt -> expr SEMICOLON .)
    VARIABLE        reduce using rule 17 (stmt -> expr SEMICOLON .)
    HASHTAG         reduce using rule 17 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 17 (stmt -> expr SEMICOLON .)
    NOT             reduce using rule 17 (stmt -> expr SEMICOLON .)
    L_PAREN         reduce using rule 17 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 17 (stmt -> expr SEMICOLON .)
    FUN             reduce using rule 17 (stmt -> expr SEMICOLON .)
    L_BRACK         reduce using rule 17 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 17 (stmt -> expr SEMICOLON .)
    WHILE           reduce using rule 17 (stmt -> expr SEMICOLON .)
    RC              reduce using rule 17 (stmt -> expr SEMICOLON .)
    LC              reduce using rule 17 (stmt -> expr SEMICOLON .)


state 44

    (42) expr -> expr POW . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 81
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 45

    (43) expr -> expr MULT . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 82
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 46

    (44) expr -> expr DIVINT . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 83
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 47

    (45) expr -> expr DIV . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 84
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 48

    (46) expr -> expr MOD . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 85
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 49

    (47) expr -> expr PLUS . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 86
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 50

    (48) expr -> expr MINUS . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 87
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 51

    (50) expr -> expr AND_ALSO . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 88
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 52

    (51) expr -> expr OR_ELSE . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 89
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 53

    (52) expr -> expr LTE . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 90
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 54

    (53) expr -> expr GTE . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 91
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 55

    (54) expr -> expr EQ_EQ . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 92
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 56

    (55) expr -> expr NEQ . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 93
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 57

    (56) expr -> expr LT . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 94
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 58

    (57) expr -> expr GT . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 95
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 59

    (58) expr -> expr IN . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 96
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 60

    (59) expr -> expr CONS . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 97
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 61

    (64) expr -> expr L_BRACK . expr R_BRACK
    (63) indexTkn -> L_BRACK . expr R_BRACK
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 98
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 62

    (37) assignment -> expr indexSequenceList . EQ expr
    (61) indexSequenceList -> indexSequenceList . indexTkn
    (63) indexTkn -> . L_BRACK expr R_BRACK

    EQ              shift and go to state 99
    L_BRACK         shift and go to state 101

    indexTkn                       shift and go to state 100

state 63

    (38) assignment -> expr EQ . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 102
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 64

    (62) indexSequenceList -> indexTkn .

    EQ              reduce using rule 62 (indexSequenceList -> indexTkn .)
    L_BRACK         reduce using rule 62 (indexSequenceList -> indexTkn .)


state 65

    (18) stmt -> print SEMICOLON .

    INTEGER         reduce using rule 18 (stmt -> print SEMICOLON .)
    FLOAT           reduce using rule 18 (stmt -> print SEMICOLON .)
    STRING          reduce using rule 18 (stmt -> print SEMICOLON .)
    BOOLEAN         reduce using rule 18 (stmt -> print SEMICOLON .)
    VARIABLE        reduce using rule 18 (stmt -> print SEMICOLON .)
    HASHTAG         reduce using rule 18 (stmt -> print SEMICOLON .)
    MINUS           reduce using rule 18 (stmt -> print SEMICOLON .)
    NOT             reduce using rule 18 (stmt -> print SEMICOLON .)
    L_PAREN         reduce using rule 18 (stmt -> print SEMICOLON .)
    PRINT           reduce using rule 18 (stmt -> print SEMICOLON .)
    FUN             reduce using rule 18 (stmt -> print SEMICOLON .)
    L_BRACK         reduce using rule 18 (stmt -> print SEMICOLON .)
    IF              reduce using rule 18 (stmt -> print SEMICOLON .)
    WHILE           reduce using rule 18 (stmt -> print SEMICOLON .)
    RC              reduce using rule 18 (stmt -> print SEMICOLON .)
    LC              reduce using rule 18 (stmt -> print SEMICOLON .)


state 66

    (19) stmt -> assignment SEMICOLON .

    INTEGER         reduce using rule 19 (stmt -> assignment SEMICOLON .)
    FLOAT           reduce using rule 19 (stmt -> assignment SEMICOLON .)
    STRING          reduce using rule 19 (stmt -> assignment SEMICOLON .)
    BOOLEAN         reduce using rule 19 (stmt -> assignment SEMICOLON .)
    VARIABLE        reduce using rule 19 (stmt -> assignment SEMICOLON .)
    HASHTAG         reduce using rule 19 (stmt -> assignment SEMICOLON .)
    MINUS           reduce using rule 19 (stmt -> assignment SEMICOLON .)
    NOT             reduce using rule 19 (stmt -> assignment SEMICOLON .)
    L_PAREN         reduce using rule 19 (stmt -> assignment SEMICOLON .)
    PRINT           reduce using rule 19 (stmt -> assignment SEMICOLON .)
    FUN             reduce using rule 19 (stmt -> assignment SEMICOLON .)
    L_BRACK         reduce using rule 19 (stmt -> assignment SEMICOLON .)
    IF              reduce using rule 19 (stmt -> assignment SEMICOLON .)
    WHILE           reduce using rule 19 (stmt -> assignment SEMICOLON .)
    RC              reduce using rule 19 (stmt -> assignment SEMICOLON .)
    LC              reduce using rule 19 (stmt -> assignment SEMICOLON .)


state 67

    (33) fun_call -> VARIABLE L_PAREN . sequence R_PAREN
    (34) fun_call -> VARIABLE L_PAREN . R_PAREN
    (67) sequence -> . expr COMMA sequence
    (68) sequence -> . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    R_PAREN         shift and go to state 104
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    sequence                       shift and go to state 103
    expr                           shift and go to state 73
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 68

    (39) expr -> HASHTAG INTEGER . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 105
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 69

    (49) expr -> MINUS expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 49 (expr -> MINUS expr .)
    MULT            reduce using rule 49 (expr -> MINUS expr .)
    DIVINT          reduce using rule 49 (expr -> MINUS expr .)
    DIV             reduce using rule 49 (expr -> MINUS expr .)
    MOD             reduce using rule 49 (expr -> MINUS expr .)
    PLUS            reduce using rule 49 (expr -> MINUS expr .)
    MINUS           reduce using rule 49 (expr -> MINUS expr .)
    AND_ALSO        reduce using rule 49 (expr -> MINUS expr .)
    OR_ELSE         reduce using rule 49 (expr -> MINUS expr .)
    LTE             reduce using rule 49 (expr -> MINUS expr .)
    GTE             reduce using rule 49 (expr -> MINUS expr .)
    EQ_EQ           reduce using rule 49 (expr -> MINUS expr .)
    NEQ             reduce using rule 49 (expr -> MINUS expr .)
    LT              reduce using rule 49 (expr -> MINUS expr .)
    GT              reduce using rule 49 (expr -> MINUS expr .)
    IN              reduce using rule 49 (expr -> MINUS expr .)
    CONS            reduce using rule 49 (expr -> MINUS expr .)
    EQ              reduce using rule 49 (expr -> MINUS expr .)
    COMMA           reduce using rule 49 (expr -> MINUS expr .)
    R_BRACK         reduce using rule 49 (expr -> MINUS expr .)
    R_PAREN         reduce using rule 49 (expr -> MINUS expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 49 (expr -> MINUS expr .) ]
  ! L_BRACK         [ reduce using rule 49 (expr -> MINUS expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 70

    (60) expr -> NOT expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 60 (expr -> NOT expr .)
    MULT            reduce using rule 60 (expr -> NOT expr .)
    DIVINT          reduce using rule 60 (expr -> NOT expr .)
    DIV             reduce using rule 60 (expr -> NOT expr .)
    MOD             reduce using rule 60 (expr -> NOT expr .)
    PLUS            reduce using rule 60 (expr -> NOT expr .)
    MINUS           reduce using rule 60 (expr -> NOT expr .)
    AND_ALSO        reduce using rule 60 (expr -> NOT expr .)
    OR_ELSE         reduce using rule 60 (expr -> NOT expr .)
    LTE             reduce using rule 60 (expr -> NOT expr .)
    GTE             reduce using rule 60 (expr -> NOT expr .)
    EQ_EQ           reduce using rule 60 (expr -> NOT expr .)
    NEQ             reduce using rule 60 (expr -> NOT expr .)
    LT              reduce using rule 60 (expr -> NOT expr .)
    GT              reduce using rule 60 (expr -> NOT expr .)
    IN              reduce using rule 60 (expr -> NOT expr .)
    CONS            reduce using rule 60 (expr -> NOT expr .)
    EQ              reduce using rule 60 (expr -> NOT expr .)
    COMMA           reduce using rule 60 (expr -> NOT expr .)
    R_BRACK         reduce using rule 60 (expr -> NOT expr .)
    R_PAREN         reduce using rule 60 (expr -> NOT expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 60 (expr -> NOT expr .) ]
  ! L_BRACK         [ reduce using rule 60 (expr -> NOT expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 71

    (65) list -> L_BRACK sequence . R_BRACK

    R_BRACK         shift and go to state 107


state 72

    (66) list -> L_BRACK R_BRACK .

    SEMICOLON       reduce using rule 66 (list -> L_BRACK R_BRACK .)
    POW             reduce using rule 66 (list -> L_BRACK R_BRACK .)
    MULT            reduce using rule 66 (list -> L_BRACK R_BRACK .)
    DIVINT          reduce using rule 66 (list -> L_BRACK R_BRACK .)
    DIV             reduce using rule 66 (list -> L_BRACK R_BRACK .)
    MOD             reduce using rule 66 (list -> L_BRACK R_BRACK .)
    PLUS            reduce using rule 66 (list -> L_BRACK R_BRACK .)
    MINUS           reduce using rule 66 (list -> L_BRACK R_BRACK .)
    AND_ALSO        reduce using rule 66 (list -> L_BRACK R_BRACK .)
    OR_ELSE         reduce using rule 66 (list -> L_BRACK R_BRACK .)
    LTE             reduce using rule 66 (list -> L_BRACK R_BRACK .)
    GTE             reduce using rule 66 (list -> L_BRACK R_BRACK .)
    EQ_EQ           reduce using rule 66 (list -> L_BRACK R_BRACK .)
    NEQ             reduce using rule 66 (list -> L_BRACK R_BRACK .)
    LT              reduce using rule 66 (list -> L_BRACK R_BRACK .)
    GT              reduce using rule 66 (list -> L_BRACK R_BRACK .)
    IN              reduce using rule 66 (list -> L_BRACK R_BRACK .)
    CONS            reduce using rule 66 (list -> L_BRACK R_BRACK .)
    L_BRACK         reduce using rule 66 (list -> L_BRACK R_BRACK .)
    EQ              reduce using rule 66 (list -> L_BRACK R_BRACK .)
    COMMA           reduce using rule 66 (list -> L_BRACK R_BRACK .)
    R_BRACK         reduce using rule 66 (list -> L_BRACK R_BRACK .)
    R_PAREN         reduce using rule 66 (list -> L_BRACK R_BRACK .)


state 73

    (67) sequence -> expr . COMMA sequence
    (68) sequence -> expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    COMMA           shift and go to state 108
    R_BRACK         reduce using rule 68 (sequence -> expr .)
    R_PAREN         reduce using rule 68 (sequence -> expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 74

    (69) expr -> L_PAREN expr . R_PAREN
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK
    (67) sequence -> expr . COMMA sequence
    (68) sequence -> expr .

  ! shift/reduce conflict for R_PAREN resolved as shift
    R_PAREN         shift and go to state 109
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106
    COMMA           shift and go to state 108

  ! R_PAREN         [ reduce using rule 68 (sequence -> expr .) ]


state 75

    (41) tuple -> L_PAREN R_PAREN .

    SEMICOLON       reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    POW             reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    MULT            reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    DIVINT          reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    DIV             reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    MOD             reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    PLUS            reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    MINUS           reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    AND_ALSO        reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    OR_ELSE         reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    LTE             reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    GTE             reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    EQ_EQ           reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    NEQ             reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    LT              reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    GT              reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    IN              reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    CONS            reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    L_BRACK         reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    EQ              reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    COMMA           reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    R_BRACK         reduce using rule 41 (tuple -> L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 41 (tuple -> L_PAREN R_PAREN .)


state 76

    (40) tuple -> L_PAREN sequence . R_PAREN

    R_PAREN         shift and go to state 110


state 77

    (16) print -> PRINT L_PAREN . expr R_PAREN
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 111
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 78

    (23) if -> IF L_PAREN . expr R_PAREN block
    (22) if_else -> IF L_PAREN . expr R_PAREN block ELSE block
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 112
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 79

    (24) while -> WHILE L_PAREN . expr R_PAREN block
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 113
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 80

    (35) fun_assignment -> FUN VARIABLE L_PAREN . sequence R_PAREN EQ block expr SEMICOLON
    (36) fun_assignment -> FUN VARIABLE L_PAREN . R_PAREN EQ block expr SEMICOLON
    (67) sequence -> . expr COMMA sequence
    (68) sequence -> . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    R_PAREN         shift and go to state 115
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    sequence                       shift and go to state 114
    expr                           shift and go to state 73
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 81

    (42) expr -> expr POW expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 42 (expr -> expr POW expr .)
    MULT            reduce using rule 42 (expr -> expr POW expr .)
    DIVINT          reduce using rule 42 (expr -> expr POW expr .)
    DIV             reduce using rule 42 (expr -> expr POW expr .)
    MOD             reduce using rule 42 (expr -> expr POW expr .)
    PLUS            reduce using rule 42 (expr -> expr POW expr .)
    MINUS           reduce using rule 42 (expr -> expr POW expr .)
    AND_ALSO        reduce using rule 42 (expr -> expr POW expr .)
    OR_ELSE         reduce using rule 42 (expr -> expr POW expr .)
    LTE             reduce using rule 42 (expr -> expr POW expr .)
    GTE             reduce using rule 42 (expr -> expr POW expr .)
    EQ_EQ           reduce using rule 42 (expr -> expr POW expr .)
    NEQ             reduce using rule 42 (expr -> expr POW expr .)
    LT              reduce using rule 42 (expr -> expr POW expr .)
    GT              reduce using rule 42 (expr -> expr POW expr .)
    IN              reduce using rule 42 (expr -> expr POW expr .)
    CONS            reduce using rule 42 (expr -> expr POW expr .)
    EQ              reduce using rule 42 (expr -> expr POW expr .)
    COMMA           reduce using rule 42 (expr -> expr POW expr .)
    R_BRACK         reduce using rule 42 (expr -> expr POW expr .)
    R_PAREN         reduce using rule 42 (expr -> expr POW expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 42 (expr -> expr POW expr .) ]
  ! L_BRACK         [ reduce using rule 42 (expr -> expr POW expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 82

    (43) expr -> expr MULT expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 43 (expr -> expr MULT expr .)
    MULT            reduce using rule 43 (expr -> expr MULT expr .)
    DIVINT          reduce using rule 43 (expr -> expr MULT expr .)
    DIV             reduce using rule 43 (expr -> expr MULT expr .)
    MOD             reduce using rule 43 (expr -> expr MULT expr .)
    PLUS            reduce using rule 43 (expr -> expr MULT expr .)
    MINUS           reduce using rule 43 (expr -> expr MULT expr .)
    AND_ALSO        reduce using rule 43 (expr -> expr MULT expr .)
    OR_ELSE         reduce using rule 43 (expr -> expr MULT expr .)
    LTE             reduce using rule 43 (expr -> expr MULT expr .)
    GTE             reduce using rule 43 (expr -> expr MULT expr .)
    EQ_EQ           reduce using rule 43 (expr -> expr MULT expr .)
    NEQ             reduce using rule 43 (expr -> expr MULT expr .)
    LT              reduce using rule 43 (expr -> expr MULT expr .)
    GT              reduce using rule 43 (expr -> expr MULT expr .)
    IN              reduce using rule 43 (expr -> expr MULT expr .)
    CONS            reduce using rule 43 (expr -> expr MULT expr .)
    EQ              reduce using rule 43 (expr -> expr MULT expr .)
    COMMA           reduce using rule 43 (expr -> expr MULT expr .)
    R_BRACK         reduce using rule 43 (expr -> expr MULT expr .)
    R_PAREN         reduce using rule 43 (expr -> expr MULT expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 43 (expr -> expr MULT expr .) ]
  ! L_BRACK         [ reduce using rule 43 (expr -> expr MULT expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 83

    (44) expr -> expr DIVINT expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 44 (expr -> expr DIVINT expr .)
    MULT            reduce using rule 44 (expr -> expr DIVINT expr .)
    DIVINT          reduce using rule 44 (expr -> expr DIVINT expr .)
    DIV             reduce using rule 44 (expr -> expr DIVINT expr .)
    MOD             reduce using rule 44 (expr -> expr DIVINT expr .)
    PLUS            reduce using rule 44 (expr -> expr DIVINT expr .)
    MINUS           reduce using rule 44 (expr -> expr DIVINT expr .)
    AND_ALSO        reduce using rule 44 (expr -> expr DIVINT expr .)
    OR_ELSE         reduce using rule 44 (expr -> expr DIVINT expr .)
    LTE             reduce using rule 44 (expr -> expr DIVINT expr .)
    GTE             reduce using rule 44 (expr -> expr DIVINT expr .)
    EQ_EQ           reduce using rule 44 (expr -> expr DIVINT expr .)
    NEQ             reduce using rule 44 (expr -> expr DIVINT expr .)
    LT              reduce using rule 44 (expr -> expr DIVINT expr .)
    GT              reduce using rule 44 (expr -> expr DIVINT expr .)
    IN              reduce using rule 44 (expr -> expr DIVINT expr .)
    CONS            reduce using rule 44 (expr -> expr DIVINT expr .)
    EQ              reduce using rule 44 (expr -> expr DIVINT expr .)
    COMMA           reduce using rule 44 (expr -> expr DIVINT expr .)
    R_BRACK         reduce using rule 44 (expr -> expr DIVINT expr .)
    R_PAREN         reduce using rule 44 (expr -> expr DIVINT expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 44 (expr -> expr DIVINT expr .) ]
  ! L_BRACK         [ reduce using rule 44 (expr -> expr DIVINT expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 84

    (45) expr -> expr DIV expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 45 (expr -> expr DIV expr .)
    MULT            reduce using rule 45 (expr -> expr DIV expr .)
    DIVINT          reduce using rule 45 (expr -> expr DIV expr .)
    DIV             reduce using rule 45 (expr -> expr DIV expr .)
    MOD             reduce using rule 45 (expr -> expr DIV expr .)
    PLUS            reduce using rule 45 (expr -> expr DIV expr .)
    MINUS           reduce using rule 45 (expr -> expr DIV expr .)
    AND_ALSO        reduce using rule 45 (expr -> expr DIV expr .)
    OR_ELSE         reduce using rule 45 (expr -> expr DIV expr .)
    LTE             reduce using rule 45 (expr -> expr DIV expr .)
    GTE             reduce using rule 45 (expr -> expr DIV expr .)
    EQ_EQ           reduce using rule 45 (expr -> expr DIV expr .)
    NEQ             reduce using rule 45 (expr -> expr DIV expr .)
    LT              reduce using rule 45 (expr -> expr DIV expr .)
    GT              reduce using rule 45 (expr -> expr DIV expr .)
    IN              reduce using rule 45 (expr -> expr DIV expr .)
    CONS            reduce using rule 45 (expr -> expr DIV expr .)
    EQ              reduce using rule 45 (expr -> expr DIV expr .)
    COMMA           reduce using rule 45 (expr -> expr DIV expr .)
    R_BRACK         reduce using rule 45 (expr -> expr DIV expr .)
    R_PAREN         reduce using rule 45 (expr -> expr DIV expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 45 (expr -> expr DIV expr .) ]
  ! L_BRACK         [ reduce using rule 45 (expr -> expr DIV expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 85

    (46) expr -> expr MOD expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 46 (expr -> expr MOD expr .)
    MULT            reduce using rule 46 (expr -> expr MOD expr .)
    DIVINT          reduce using rule 46 (expr -> expr MOD expr .)
    DIV             reduce using rule 46 (expr -> expr MOD expr .)
    MOD             reduce using rule 46 (expr -> expr MOD expr .)
    PLUS            reduce using rule 46 (expr -> expr MOD expr .)
    MINUS           reduce using rule 46 (expr -> expr MOD expr .)
    AND_ALSO        reduce using rule 46 (expr -> expr MOD expr .)
    OR_ELSE         reduce using rule 46 (expr -> expr MOD expr .)
    LTE             reduce using rule 46 (expr -> expr MOD expr .)
    GTE             reduce using rule 46 (expr -> expr MOD expr .)
    EQ_EQ           reduce using rule 46 (expr -> expr MOD expr .)
    NEQ             reduce using rule 46 (expr -> expr MOD expr .)
    LT              reduce using rule 46 (expr -> expr MOD expr .)
    GT              reduce using rule 46 (expr -> expr MOD expr .)
    IN              reduce using rule 46 (expr -> expr MOD expr .)
    CONS            reduce using rule 46 (expr -> expr MOD expr .)
    EQ              reduce using rule 46 (expr -> expr MOD expr .)
    COMMA           reduce using rule 46 (expr -> expr MOD expr .)
    R_BRACK         reduce using rule 46 (expr -> expr MOD expr .)
    R_PAREN         reduce using rule 46 (expr -> expr MOD expr .)
    POW             shift and go to state 44
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 46 (expr -> expr MOD expr .) ]
  ! L_BRACK         [ reduce using rule 46 (expr -> expr MOD expr .) ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 86

    (47) expr -> expr PLUS expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 47 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 47 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 47 (expr -> expr PLUS expr .)
    AND_ALSO        reduce using rule 47 (expr -> expr PLUS expr .)
    OR_ELSE         reduce using rule 47 (expr -> expr PLUS expr .)
    LTE             reduce using rule 47 (expr -> expr PLUS expr .)
    GTE             reduce using rule 47 (expr -> expr PLUS expr .)
    EQ_EQ           reduce using rule 47 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 47 (expr -> expr PLUS expr .)
    LT              reduce using rule 47 (expr -> expr PLUS expr .)
    GT              reduce using rule 47 (expr -> expr PLUS expr .)
    IN              reduce using rule 47 (expr -> expr PLUS expr .)
    CONS            reduce using rule 47 (expr -> expr PLUS expr .)
    EQ              reduce using rule 47 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 47 (expr -> expr PLUS expr .)
    R_BRACK         reduce using rule 47 (expr -> expr PLUS expr .)
    R_PAREN         reduce using rule 47 (expr -> expr PLUS expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! MULT            [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! DIVINT          [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! L_BRACK         [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 87

    (48) expr -> expr MINUS expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 48 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 48 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 48 (expr -> expr MINUS expr .)
    AND_ALSO        reduce using rule 48 (expr -> expr MINUS expr .)
    OR_ELSE         reduce using rule 48 (expr -> expr MINUS expr .)
    LTE             reduce using rule 48 (expr -> expr MINUS expr .)
    GTE             reduce using rule 48 (expr -> expr MINUS expr .)
    EQ_EQ           reduce using rule 48 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 48 (expr -> expr MINUS expr .)
    LT              reduce using rule 48 (expr -> expr MINUS expr .)
    GT              reduce using rule 48 (expr -> expr MINUS expr .)
    IN              reduce using rule 48 (expr -> expr MINUS expr .)
    CONS            reduce using rule 48 (expr -> expr MINUS expr .)
    EQ              reduce using rule 48 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 48 (expr -> expr MINUS expr .)
    R_BRACK         reduce using rule 48 (expr -> expr MINUS expr .)
    R_PAREN         reduce using rule 48 (expr -> expr MINUS expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! MULT            [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! DIVINT          [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! L_BRACK         [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 88

    (50) expr -> expr AND_ALSO expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 50 (expr -> expr AND_ALSO expr .)
    AND_ALSO        reduce using rule 50 (expr -> expr AND_ALSO expr .)
    OR_ELSE         reduce using rule 50 (expr -> expr AND_ALSO expr .)
    EQ              reduce using rule 50 (expr -> expr AND_ALSO expr .)
    COMMA           reduce using rule 50 (expr -> expr AND_ALSO expr .)
    R_BRACK         reduce using rule 50 (expr -> expr AND_ALSO expr .)
    R_PAREN         reduce using rule 50 (expr -> expr AND_ALSO expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! MULT            [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! DIVINT          [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! DIV             [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! MOD             [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! PLUS            [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! MINUS           [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! LTE             [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! GTE             [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! EQ_EQ           [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! NEQ             [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! LT              [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! GT              [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! IN              [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! CONS            [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! L_BRACK         [ reduce using rule 50 (expr -> expr AND_ALSO expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]


state 89

    (51) expr -> expr OR_ELSE expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 51 (expr -> expr OR_ELSE expr .)
    AND_ALSO        reduce using rule 51 (expr -> expr OR_ELSE expr .)
    OR_ELSE         reduce using rule 51 (expr -> expr OR_ELSE expr .)
    EQ              reduce using rule 51 (expr -> expr OR_ELSE expr .)
    COMMA           reduce using rule 51 (expr -> expr OR_ELSE expr .)
    R_BRACK         reduce using rule 51 (expr -> expr OR_ELSE expr .)
    R_PAREN         reduce using rule 51 (expr -> expr OR_ELSE expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! MULT            [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! DIVINT          [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! DIV             [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! MOD             [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! PLUS            [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! MINUS           [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! LTE             [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! GTE             [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! EQ_EQ           [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! NEQ             [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! LT              [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! GT              [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! IN              [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! CONS            [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! L_BRACK         [ reduce using rule 51 (expr -> expr OR_ELSE expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]


state 90

    (52) expr -> expr LTE expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 52 (expr -> expr LTE expr .)
    AND_ALSO        reduce using rule 52 (expr -> expr LTE expr .)
    OR_ELSE         reduce using rule 52 (expr -> expr LTE expr .)
    LTE             reduce using rule 52 (expr -> expr LTE expr .)
    GTE             reduce using rule 52 (expr -> expr LTE expr .)
    EQ_EQ           reduce using rule 52 (expr -> expr LTE expr .)
    NEQ             reduce using rule 52 (expr -> expr LTE expr .)
    LT              reduce using rule 52 (expr -> expr LTE expr .)
    GT              reduce using rule 52 (expr -> expr LTE expr .)
    EQ              reduce using rule 52 (expr -> expr LTE expr .)
    COMMA           reduce using rule 52 (expr -> expr LTE expr .)
    R_BRACK         reduce using rule 52 (expr -> expr LTE expr .)
    R_PAREN         reduce using rule 52 (expr -> expr LTE expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! MULT            [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! DIVINT          [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! DIV             [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! MOD             [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! PLUS            [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! IN              [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! CONS            [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! L_BRACK         [ reduce using rule 52 (expr -> expr LTE expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 91

    (53) expr -> expr GTE expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 53 (expr -> expr GTE expr .)
    AND_ALSO        reduce using rule 53 (expr -> expr GTE expr .)
    OR_ELSE         reduce using rule 53 (expr -> expr GTE expr .)
    LTE             reduce using rule 53 (expr -> expr GTE expr .)
    GTE             reduce using rule 53 (expr -> expr GTE expr .)
    EQ_EQ           reduce using rule 53 (expr -> expr GTE expr .)
    NEQ             reduce using rule 53 (expr -> expr GTE expr .)
    LT              reduce using rule 53 (expr -> expr GTE expr .)
    GT              reduce using rule 53 (expr -> expr GTE expr .)
    EQ              reduce using rule 53 (expr -> expr GTE expr .)
    COMMA           reduce using rule 53 (expr -> expr GTE expr .)
    R_BRACK         reduce using rule 53 (expr -> expr GTE expr .)
    R_PAREN         reduce using rule 53 (expr -> expr GTE expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! MULT            [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! DIVINT          [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! DIV             [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! MOD             [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! PLUS            [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! IN              [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! CONS            [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! L_BRACK         [ reduce using rule 53 (expr -> expr GTE expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 92

    (54) expr -> expr EQ_EQ expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 54 (expr -> expr EQ_EQ expr .)
    AND_ALSO        reduce using rule 54 (expr -> expr EQ_EQ expr .)
    OR_ELSE         reduce using rule 54 (expr -> expr EQ_EQ expr .)
    LTE             reduce using rule 54 (expr -> expr EQ_EQ expr .)
    GTE             reduce using rule 54 (expr -> expr EQ_EQ expr .)
    EQ_EQ           reduce using rule 54 (expr -> expr EQ_EQ expr .)
    NEQ             reduce using rule 54 (expr -> expr EQ_EQ expr .)
    LT              reduce using rule 54 (expr -> expr EQ_EQ expr .)
    GT              reduce using rule 54 (expr -> expr EQ_EQ expr .)
    EQ              reduce using rule 54 (expr -> expr EQ_EQ expr .)
    COMMA           reduce using rule 54 (expr -> expr EQ_EQ expr .)
    R_BRACK         reduce using rule 54 (expr -> expr EQ_EQ expr .)
    R_PAREN         reduce using rule 54 (expr -> expr EQ_EQ expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! MULT            [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! DIVINT          [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! DIV             [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! MOD             [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! PLUS            [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! MINUS           [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! IN              [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! CONS            [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! L_BRACK         [ reduce using rule 54 (expr -> expr EQ_EQ expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 93

    (55) expr -> expr NEQ expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 55 (expr -> expr NEQ expr .)
    AND_ALSO        reduce using rule 55 (expr -> expr NEQ expr .)
    OR_ELSE         reduce using rule 55 (expr -> expr NEQ expr .)
    LTE             reduce using rule 55 (expr -> expr NEQ expr .)
    GTE             reduce using rule 55 (expr -> expr NEQ expr .)
    EQ_EQ           reduce using rule 55 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 55 (expr -> expr NEQ expr .)
    LT              reduce using rule 55 (expr -> expr NEQ expr .)
    GT              reduce using rule 55 (expr -> expr NEQ expr .)
    EQ              reduce using rule 55 (expr -> expr NEQ expr .)
    COMMA           reduce using rule 55 (expr -> expr NEQ expr .)
    R_BRACK         reduce using rule 55 (expr -> expr NEQ expr .)
    R_PAREN         reduce using rule 55 (expr -> expr NEQ expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MULT            [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! DIVINT          [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! DIV             [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MOD             [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! PLUS            [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MINUS           [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! IN              [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! CONS            [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! L_BRACK         [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 94

    (56) expr -> expr LT expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 56 (expr -> expr LT expr .)
    AND_ALSO        reduce using rule 56 (expr -> expr LT expr .)
    OR_ELSE         reduce using rule 56 (expr -> expr LT expr .)
    LTE             reduce using rule 56 (expr -> expr LT expr .)
    GTE             reduce using rule 56 (expr -> expr LT expr .)
    EQ_EQ           reduce using rule 56 (expr -> expr LT expr .)
    NEQ             reduce using rule 56 (expr -> expr LT expr .)
    LT              reduce using rule 56 (expr -> expr LT expr .)
    GT              reduce using rule 56 (expr -> expr LT expr .)
    EQ              reduce using rule 56 (expr -> expr LT expr .)
    COMMA           reduce using rule 56 (expr -> expr LT expr .)
    R_BRACK         reduce using rule 56 (expr -> expr LT expr .)
    R_PAREN         reduce using rule 56 (expr -> expr LT expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! MULT            [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! DIVINT          [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! IN              [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! CONS            [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! L_BRACK         [ reduce using rule 56 (expr -> expr LT expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 95

    (57) expr -> expr GT expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 57 (expr -> expr GT expr .)
    AND_ALSO        reduce using rule 57 (expr -> expr GT expr .)
    OR_ELSE         reduce using rule 57 (expr -> expr GT expr .)
    LTE             reduce using rule 57 (expr -> expr GT expr .)
    GTE             reduce using rule 57 (expr -> expr GT expr .)
    EQ_EQ           reduce using rule 57 (expr -> expr GT expr .)
    NEQ             reduce using rule 57 (expr -> expr GT expr .)
    LT              reduce using rule 57 (expr -> expr GT expr .)
    GT              reduce using rule 57 (expr -> expr GT expr .)
    EQ              reduce using rule 57 (expr -> expr GT expr .)
    COMMA           reduce using rule 57 (expr -> expr GT expr .)
    R_BRACK         reduce using rule 57 (expr -> expr GT expr .)
    R_PAREN         reduce using rule 57 (expr -> expr GT expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! MULT            [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! DIVINT          [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! IN              [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! CONS            [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! L_BRACK         [ reduce using rule 57 (expr -> expr GT expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 96

    (58) expr -> expr IN expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 58 (expr -> expr IN expr .)
    AND_ALSO        reduce using rule 58 (expr -> expr IN expr .)
    OR_ELSE         reduce using rule 58 (expr -> expr IN expr .)
    LTE             reduce using rule 58 (expr -> expr IN expr .)
    GTE             reduce using rule 58 (expr -> expr IN expr .)
    EQ_EQ           reduce using rule 58 (expr -> expr IN expr .)
    NEQ             reduce using rule 58 (expr -> expr IN expr .)
    LT              reduce using rule 58 (expr -> expr IN expr .)
    GT              reduce using rule 58 (expr -> expr IN expr .)
    IN              reduce using rule 58 (expr -> expr IN expr .)
    CONS            reduce using rule 58 (expr -> expr IN expr .)
    EQ              reduce using rule 58 (expr -> expr IN expr .)
    COMMA           reduce using rule 58 (expr -> expr IN expr .)
    R_BRACK         reduce using rule 58 (expr -> expr IN expr .)
    R_PAREN         reduce using rule 58 (expr -> expr IN expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! MULT            [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! DIVINT          [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! DIV             [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! MOD             [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! PLUS            [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! MINUS           [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! L_BRACK         [ reduce using rule 58 (expr -> expr IN expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]


state 97

    (59) expr -> expr CONS expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 59 (expr -> expr CONS expr .)
    AND_ALSO        reduce using rule 59 (expr -> expr CONS expr .)
    OR_ELSE         reduce using rule 59 (expr -> expr CONS expr .)
    LTE             reduce using rule 59 (expr -> expr CONS expr .)
    GTE             reduce using rule 59 (expr -> expr CONS expr .)
    EQ_EQ           reduce using rule 59 (expr -> expr CONS expr .)
    NEQ             reduce using rule 59 (expr -> expr CONS expr .)
    LT              reduce using rule 59 (expr -> expr CONS expr .)
    GT              reduce using rule 59 (expr -> expr CONS expr .)
    EQ              reduce using rule 59 (expr -> expr CONS expr .)
    COMMA           reduce using rule 59 (expr -> expr CONS expr .)
    R_BRACK         reduce using rule 59 (expr -> expr CONS expr .)
    R_PAREN         reduce using rule 59 (expr -> expr CONS expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106

  ! POW             [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! MULT            [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! DIVINT          [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! DIV             [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! MOD             [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! PLUS            [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! MINUS           [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! IN              [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! CONS            [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! L_BRACK         [ reduce using rule 59 (expr -> expr CONS expr .) ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]


state 98

    (64) expr -> expr L_BRACK expr . R_BRACK
    (63) indexTkn -> L_BRACK expr . R_BRACK
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    R_BRACK         shift and go to state 116
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 99

    (37) assignment -> expr indexSequenceList EQ . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 117
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 100

    (61) indexSequenceList -> indexSequenceList indexTkn .

    EQ              reduce using rule 61 (indexSequenceList -> indexSequenceList indexTkn .)
    L_BRACK         reduce using rule 61 (indexSequenceList -> indexSequenceList indexTkn .)


state 101

    (63) indexTkn -> L_BRACK . expr R_BRACK
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 118
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 102

    (38) assignment -> expr EQ expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 38 (assignment -> expr EQ expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 103

    (33) fun_call -> VARIABLE L_PAREN sequence . R_PAREN

    R_PAREN         shift and go to state 119


state 104

    (34) fun_call -> VARIABLE L_PAREN R_PAREN .

    SEMICOLON       reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    POW             reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    MULT            reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    DIVINT          reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    DIV             reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    MOD             reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    PLUS            reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    MINUS           reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    AND_ALSO        reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    OR_ELSE         reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    LTE             reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    GTE             reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    EQ_EQ           reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    NEQ             reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    LT              reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    GT              reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    IN              reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    CONS            reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    L_BRACK         reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    EQ              reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    COMMA           reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    R_BRACK         reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 34 (fun_call -> VARIABLE L_PAREN R_PAREN .)


state 105

    (39) expr -> HASHTAG INTEGER expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    POW             reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    MULT            reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    DIVINT          reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    DIV             reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    MOD             reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    PLUS            reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    MINUS           reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    AND_ALSO        reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    OR_ELSE         reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    LTE             reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    GTE             reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    EQ_EQ           reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    NEQ             reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    LT              reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    GT              reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    IN              reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    CONS            reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    L_BRACK         reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    EQ              reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    COMMA           reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    R_BRACK         reduce using rule 39 (expr -> HASHTAG INTEGER expr .)
    R_PAREN         reduce using rule 39 (expr -> HASHTAG INTEGER expr .)

  ! POW             [ shift and go to state 44 ]
  ! MULT            [ shift and go to state 45 ]
  ! DIVINT          [ shift and go to state 46 ]
  ! DIV             [ shift and go to state 47 ]
  ! MOD             [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 49 ]
  ! MINUS           [ shift and go to state 50 ]
  ! AND_ALSO        [ shift and go to state 51 ]
  ! OR_ELSE         [ shift and go to state 52 ]
  ! LTE             [ shift and go to state 53 ]
  ! GTE             [ shift and go to state 54 ]
  ! EQ_EQ           [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! IN              [ shift and go to state 59 ]
  ! CONS            [ shift and go to state 60 ]
  ! L_BRACK         [ shift and go to state 106 ]


state 106

    (64) expr -> expr L_BRACK . expr R_BRACK
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 120
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 107

    (65) list -> L_BRACK sequence R_BRACK .

    SEMICOLON       reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    POW             reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    MULT            reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    DIVINT          reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    DIV             reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    MOD             reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    PLUS            reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    MINUS           reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    AND_ALSO        reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    OR_ELSE         reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    LTE             reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    GTE             reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    EQ_EQ           reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    NEQ             reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    LT              reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    GT              reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    IN              reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    CONS            reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    L_BRACK         reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    EQ              reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    COMMA           reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    R_BRACK         reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)
    R_PAREN         reduce using rule 65 (list -> L_BRACK sequence R_BRACK .)


state 108

    (67) sequence -> expr COMMA . sequence
    (67) sequence -> . expr COMMA sequence
    (68) sequence -> . expr
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 73
    sequence                       shift and go to state 121
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 109

    (69) expr -> L_PAREN expr R_PAREN .

    SEMICOLON       reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    POW             reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    MULT            reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    DIVINT          reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    DIV             reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    AND_ALSO        reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    OR_ELSE         reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    LTE             reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    GTE             reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    EQ_EQ           reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    NEQ             reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    IN              reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    CONS            reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    L_BRACK         reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    R_BRACK         reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 69 (expr -> L_PAREN expr R_PAREN .)


state 110

    (40) tuple -> L_PAREN sequence R_PAREN .

    SEMICOLON       reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    POW             reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    MULT            reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    DIVINT          reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    DIV             reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    MOD             reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    PLUS            reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    MINUS           reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    AND_ALSO        reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    OR_ELSE         reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    LTE             reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    GTE             reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    EQ_EQ           reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    NEQ             reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    LT              reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    GT              reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    IN              reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    CONS            reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    L_BRACK         reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    EQ              reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    COMMA           reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    R_BRACK         reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)
    R_PAREN         reduce using rule 40 (tuple -> L_PAREN sequence R_PAREN .)


state 111

    (16) print -> PRINT L_PAREN expr . R_PAREN
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    R_PAREN         shift and go to state 122
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 112

    (23) if -> IF L_PAREN expr . R_PAREN block
    (22) if_else -> IF L_PAREN expr . R_PAREN block ELSE block
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    R_PAREN         shift and go to state 123
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 113

    (24) while -> WHILE L_PAREN expr . R_PAREN block
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    R_PAREN         shift and go to state 124
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 114

    (35) fun_assignment -> FUN VARIABLE L_PAREN sequence . R_PAREN EQ block expr SEMICOLON

    R_PAREN         shift and go to state 125


state 115

    (36) fun_assignment -> FUN VARIABLE L_PAREN R_PAREN . EQ block expr SEMICOLON

    EQ              shift and go to state 126


state 116

    (64) expr -> expr L_BRACK expr R_BRACK .
    (63) indexTkn -> L_BRACK expr R_BRACK .

  ! reduce/reduce conflict for EQ resolved using rule 63 (indexTkn -> L_BRACK expr R_BRACK .)
  ! reduce/reduce conflict for L_BRACK resolved using rule 63 (indexTkn -> L_BRACK expr R_BRACK .)
    SEMICOLON       reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    POW             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    MULT            reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    DIVINT          reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    DIV             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    MOD             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    PLUS            reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    MINUS           reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    AND_ALSO        reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    OR_ELSE         reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    LTE             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    GTE             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    EQ_EQ           reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    NEQ             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    LT              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    GT              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    IN              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    CONS            reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    EQ              reduce using rule 63 (indexTkn -> L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 63 (indexTkn -> L_BRACK expr R_BRACK .)

  ! L_BRACK         [ reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .) ]
  ! EQ              [ reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .) ]


state 117

    (37) assignment -> expr indexSequenceList EQ expr .
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 37 (assignment -> expr indexSequenceList EQ expr .)
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 118

    (63) indexTkn -> L_BRACK expr . R_BRACK
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    R_BRACK         shift and go to state 127
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 119

    (33) fun_call -> VARIABLE L_PAREN sequence R_PAREN .

    SEMICOLON       reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    POW             reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    MULT            reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    DIVINT          reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    DIV             reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    MOD             reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    PLUS            reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    MINUS           reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    AND_ALSO        reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    OR_ELSE         reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    LTE             reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    GTE             reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    EQ_EQ           reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    NEQ             reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    LT              reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    GT              reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    IN              reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    CONS            reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    L_BRACK         reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    EQ              reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    COMMA           reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    R_BRACK         reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)
    R_PAREN         reduce using rule 33 (fun_call -> VARIABLE L_PAREN sequence R_PAREN .)


state 120

    (64) expr -> expr L_BRACK expr . R_BRACK
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    R_BRACK         shift and go to state 128
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 121

    (67) sequence -> expr COMMA sequence .

    R_BRACK         reduce using rule 67 (sequence -> expr COMMA sequence .)
    R_PAREN         reduce using rule 67 (sequence -> expr COMMA sequence .)


state 122

    (16) print -> PRINT L_PAREN expr R_PAREN .

    SEMICOLON       reduce using rule 16 (print -> PRINT L_PAREN expr R_PAREN .)


state 123

    (23) if -> IF L_PAREN expr R_PAREN . block
    (22) if_else -> IF L_PAREN expr R_PAREN . block ELSE block
    (14) block -> . LC block_list RC
    (15) block -> . LC RC

    LC              shift and go to state 5

    block                          shift and go to state 129

state 124

    (24) while -> WHILE L_PAREN expr R_PAREN . block
    (14) block -> . LC block_list RC
    (15) block -> . LC RC

    LC              shift and go to state 5

    block                          shift and go to state 130

state 125

    (35) fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN . EQ block expr SEMICOLON

    EQ              shift and go to state 131


state 126

    (36) fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ . block expr SEMICOLON
    (14) block -> . LC block_list RC
    (15) block -> . LC RC

    LC              shift and go to state 5

    block                          shift and go to state 132

state 127

    (63) indexTkn -> L_BRACK expr R_BRACK .

    EQ              reduce using rule 63 (indexTkn -> L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 63 (indexTkn -> L_BRACK expr R_BRACK .)


state 128

    (64) expr -> expr L_BRACK expr R_BRACK .

    POW             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    MULT            reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    DIVINT          reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    DIV             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    MOD             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    PLUS            reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    MINUS           reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    AND_ALSO        reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    OR_ELSE         reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    LTE             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    GTE             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    EQ_EQ           reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    NEQ             reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    LT              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    GT              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    IN              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    CONS            reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    SEMICOLON       reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    EQ              reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    COMMA           reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    R_BRACK         reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)
    R_PAREN         reduce using rule 64 (expr -> expr L_BRACK expr R_BRACK .)


state 129

    (23) if -> IF L_PAREN expr R_PAREN block .
    (22) if_else -> IF L_PAREN expr R_PAREN block . ELSE block

    INTEGER         reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    FLOAT           reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    STRING          reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    BOOLEAN         reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    VARIABLE        reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    HASHTAG         reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    MINUS           reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    NOT             reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    L_PAREN         reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    PRINT           reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    FUN             reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    L_BRACK         reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    IF              reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    WHILE           reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    RC              reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    LC              reduce using rule 23 (if -> IF L_PAREN expr R_PAREN block .)
    ELSE            shift and go to state 133


state 130

    (24) while -> WHILE L_PAREN expr R_PAREN block .

    INTEGER         reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    FLOAT           reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    STRING          reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    BOOLEAN         reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    VARIABLE        reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    HASHTAG         reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    MINUS           reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    NOT             reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    L_PAREN         reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    PRINT           reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    FUN             reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    L_BRACK         reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    IF              reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    WHILE           reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    RC              reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)
    LC              reduce using rule 24 (while -> WHILE L_PAREN expr R_PAREN block .)


state 131

    (35) fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ . block expr SEMICOLON
    (14) block -> . LC block_list RC
    (15) block -> . LC RC

    LC              shift and go to state 5

    block                          shift and go to state 134

state 132

    (36) fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block . expr SEMICOLON
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 135
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 133

    (22) if_else -> IF L_PAREN expr R_PAREN block ELSE . block
    (14) block -> . LC block_list RC
    (15) block -> . LC RC

    LC              shift and go to state 5

    block                          shift and go to state 136

state 134

    (35) fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block . expr SEMICOLON
    (25) expr -> . INTEGER
    (26) expr -> . FLOAT
    (27) expr -> . STRING
    (28) expr -> . BOOLEAN
    (29) expr -> . fun_call
    (30) expr -> . VARIABLE
    (31) expr -> . list
    (32) expr -> . tuple
    (39) expr -> . HASHTAG INTEGER expr
    (42) expr -> . expr POW expr
    (43) expr -> . expr MULT expr
    (44) expr -> . expr DIVINT expr
    (45) expr -> . expr DIV expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . MINUS expr
    (50) expr -> . expr AND_ALSO expr
    (51) expr -> . expr OR_ELSE expr
    (52) expr -> . expr LTE expr
    (53) expr -> . expr GTE expr
    (54) expr -> . expr EQ_EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr LT expr
    (57) expr -> . expr GT expr
    (58) expr -> . expr IN expr
    (59) expr -> . expr CONS expr
    (60) expr -> . NOT expr
    (64) expr -> . expr L_BRACK expr R_BRACK
    (69) expr -> . L_PAREN expr R_PAREN
    (33) fun_call -> . VARIABLE L_PAREN sequence R_PAREN
    (34) fun_call -> . VARIABLE L_PAREN R_PAREN
    (65) list -> . L_BRACK sequence R_BRACK
    (66) list -> . L_BRACK R_BRACK
    (40) tuple -> . L_PAREN sequence R_PAREN
    (41) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    BOOLEAN         shift and go to state 22
    VARIABLE        shift and go to state 24
    HASHTAG         shift and go to state 27
    MINUS           shift and go to state 28
    NOT             shift and go to state 29
    L_PAREN         shift and go to state 31
    L_BRACK         shift and go to state 30

    expr                           shift and go to state 137
    fun_call                       shift and go to state 23
    list                           shift and go to state 25
    tuple                          shift and go to state 26

state 135

    (36) fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr . SEMICOLON
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       shift and go to state 138
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 136

    (22) if_else -> IF L_PAREN expr R_PAREN block ELSE block .

    INTEGER         reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    FLOAT           reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    STRING          reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    BOOLEAN         reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    VARIABLE        reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    HASHTAG         reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    MINUS           reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    NOT             reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    L_PAREN         reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    PRINT           reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    FUN             reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    L_BRACK         reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    IF              reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    WHILE           reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    RC              reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    LC              reduce using rule 22 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)


state 137

    (35) fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr . SEMICOLON
    (42) expr -> expr . POW expr
    (43) expr -> expr . MULT expr
    (44) expr -> expr . DIVINT expr
    (45) expr -> expr . DIV expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (50) expr -> expr . AND_ALSO expr
    (51) expr -> expr . OR_ELSE expr
    (52) expr -> expr . LTE expr
    (53) expr -> expr . GTE expr
    (54) expr -> expr . EQ_EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . LT expr
    (57) expr -> expr . GT expr
    (58) expr -> expr . IN expr
    (59) expr -> expr . CONS expr
    (64) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       shift and go to state 139
    POW             shift and go to state 44
    MULT            shift and go to state 45
    DIVINT          shift and go to state 46
    DIV             shift and go to state 47
    MOD             shift and go to state 48
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    AND_ALSO        shift and go to state 51
    OR_ELSE         shift and go to state 52
    LTE             shift and go to state 53
    GTE             shift and go to state 54
    EQ_EQ           shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    IN              shift and go to state 59
    CONS            shift and go to state 60
    L_BRACK         shift and go to state 106


state 138

    (36) fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .

    LC              reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    FUN             reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    INTEGER         reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    FLOAT           reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    STRING          reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    BOOLEAN         reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    VARIABLE        reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    HASHTAG         reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    MINUS           reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    NOT             reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    L_PAREN         reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    PRINT           reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    L_BRACK         reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    IF              reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    WHILE           reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)
    RC              reduce using rule 36 (fun_assignment -> FUN VARIABLE L_PAREN R_PAREN EQ block expr SEMICOLON .)


state 139

    (35) fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .

    LC              reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    FUN             reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    INTEGER         reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    FLOAT           reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    STRING          reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    BOOLEAN         reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    VARIABLE        reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    HASHTAG         reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    MINUS           reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    NOT             reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    L_PAREN         reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    PRINT           reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    L_BRACK         reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    IF              reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    WHILE           reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)
    RC              reduce using rule 35 (fun_assignment -> FUN VARIABLE L_PAREN sequence R_PAREN EQ block expr SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INTEGER in state 11 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 11 resolved as shift
WARNING: shift/reduce conflict for STRING in state 11 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 11 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 11 resolved as shift
WARNING: shift/reduce conflict for HASHTAG in state 11 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 11 resolved as shift
WARNING: shift/reduce conflict for NOT in state 11 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 11 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 11 resolved as shift
WARNING: shift/reduce conflict for FUN in state 11 resolved as shift
WARNING: shift/reduce conflict for L_BRACK in state 11 resolved as shift
WARNING: shift/reduce conflict for IF in state 11 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 11 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 40 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 40 resolved as shift
WARNING: shift/reduce conflict for STRING in state 40 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 40 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 40 resolved as shift
WARNING: shift/reduce conflict for HASHTAG in state 40 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 40 resolved as shift
WARNING: shift/reduce conflict for NOT in state 40 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 40 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 40 resolved as shift
WARNING: shift/reduce conflict for FUN in state 40 resolved as shift
WARNING: shift/reduce conflict for L_BRACK in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for R_PAREN in state 74 resolved as shift
WARNING: reduce/reduce conflict in state 116 resolved using rule (indexTkn -> L_BRACK expr R_BRACK)
WARNING: rejected rule (expr -> expr L_BRACK expr R_BRACK) in state 116
