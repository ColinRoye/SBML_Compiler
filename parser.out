Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON

Grammar

Rule 0     S' -> program
Rule 1     program -> block_list
Rule 2     block_list -> block_list stmt_list
Rule 3     block_list -> stmt_list
Rule 4     block_list -> block_list block
Rule 5     block_list -> block
Rule 6     cond_stmt -> if
Rule 7     cond_stmt -> if_else
Rule 8     cond_stmt -> while
Rule 9     stmt_list -> stmt_list stmt
Rule 10    stmt_list -> stmt
Rule 11    block -> LC block_list RC
Rule 12    block -> LC RC
Rule 13    print -> PRINT L_PAREN expr R_PAREN
Rule 14    stmt -> expr SEMICOLON
Rule 15    stmt -> print SEMICOLON
Rule 16    stmt -> assignment SEMICOLON
Rule 17    stmt -> cond_stmt
Rule 18    if_else -> IF L_PAREN expr R_PAREN block ELSE block
Rule 19    if -> IF L_PAREN expr R_PAREN block
Rule 20    while -> WHILE L_PAREN expr R_PAREN block
Rule 21    expr -> INTEGER
Rule 22    expr -> FLOAT
Rule 23    expr -> STRING
Rule 24    expr -> BOOLEAN
Rule 25    expr -> VARIABLE
Rule 26    expr -> list
Rule 27    expr -> tuple
Rule 28    assignment -> expr indexSequenceList EQ expr
Rule 29    assignment -> expr EQ expr
Rule 30    expr -> HASHTAG INTEGER expr
Rule 31    tuple -> L_PAREN sequence R_PAREN
Rule 32    tuple -> L_PAREN R_PAREN
Rule 33    expr -> expr POW expr
Rule 34    expr -> expr MULT expr
Rule 35    expr -> expr DIVINT expr
Rule 36    expr -> expr DIV expr
Rule 37    expr -> expr MOD expr
Rule 38    expr -> expr PLUS expr
Rule 39    expr -> expr MINUS expr
Rule 40    expr -> MINUS expr
Rule 41    expr -> expr AND_ALSO expr
Rule 42    expr -> expr OR_ELSE expr
Rule 43    expr -> expr LTE expr
Rule 44    expr -> expr GTE expr
Rule 45    expr -> expr EQ_EQ expr
Rule 46    expr -> expr NEQ expr
Rule 47    expr -> expr LT expr
Rule 48    expr -> expr GT expr
Rule 49    expr -> expr IN expr
Rule 50    expr -> expr CONS expr
Rule 51    expr -> NOT expr
Rule 52    indexSequenceList -> indexSequenceList indexTkn
Rule 53    indexSequenceList -> indexTkn
Rule 54    indexTkn -> L_BRACK expr R_BRACK
Rule 55    expr -> expr L_BRACK expr R_BRACK
Rule 56    list -> L_BRACK sequence R_BRACK
Rule 57    list -> L_BRACK R_BRACK
Rule 58    sequence -> expr COMMA sequence
Rule 59    sequence -> expr
Rule 60    expr -> L_PAREN expr R_PAREN

Terminals, with rules where they appear

AND_ALSO             : 41
BOOLEAN              : 24
COLON                : 
COMMA                : 58
CONS                 : 50
DIV                  : 36
DIVINT               : 35
ELSE                 : 18
EQ                   : 28 29
EQ_EQ                : 45
FLOAT                : 22
GT                   : 48
GTE                  : 44
HASHTAG              : 30
IF                   : 18 19
IN                   : 49
INTEGER              : 21 30
LC                   : 11 12
LT                   : 47
LTE                  : 43
L_BRACK              : 54 55 56 57
L_PAREN              : 13 18 19 20 31 32 60
MINUS                : 39 40
MOD                  : 37
MULT                 : 34
NEQ                  : 46
NOT                  : 51
OR_ELSE              : 42
PLUS                 : 38
POW                  : 33
PRINT                : 13
RC                   : 11 12
R_BRACK              : 54 55 56 57
R_PAREN              : 13 18 19 20 31 32 60
SEMICOLON            : 14 15 16
STRING               : 23
VARIABLE             : 25
WHILE                : 20
error                : 

Nonterminals, with rules where they appear

assignment           : 16
block                : 4 5 18 18 19 20
block_list           : 1 2 4 11
cond_stmt            : 17
expr                 : 13 14 18 19 20 28 28 29 29 30 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 54 55 55 58 59 60
if                   : 6
if_else              : 7
indexSequenceList    : 28 52
indexTkn             : 52 53
list                 : 26
print                : 15
program              : 0
sequence             : 31 56 58
stmt                 : 9 10
stmt_list            : 2 3 9
tuple                : 27
while                : 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block_list
    (2) block_list -> . block_list stmt_list
    (3) block_list -> . stmt_list
    (4) block_list -> . block_list block
    (5) block_list -> . block
    (9) stmt_list -> . stmt_list stmt
    (10) stmt_list -> . stmt
    (11) block -> . LC block_list RC
    (12) block -> . LC RC
    (14) stmt -> . expr SEMICOLON
    (15) stmt -> . print SEMICOLON
    (16) stmt -> . assignment SEMICOLON
    (17) stmt -> . cond_stmt
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (13) print -> . PRINT L_PAREN expr R_PAREN
    (28) assignment -> . expr indexSequenceList EQ expr
    (29) assignment -> . expr EQ expr
    (6) cond_stmt -> . if
    (7) cond_stmt -> . if_else
    (8) cond_stmt -> . while
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN
    (19) if -> . IF L_PAREN expr R_PAREN block
    (18) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (20) while -> . WHILE L_PAREN expr R_PAREN block

    LC              shift and go to state 6
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    PRINT           shift and go to state 23
    L_BRACK         shift and go to state 21
    IF              shift and go to state 27
    WHILE           shift and go to state 28

    program                        shift and go to state 1
    block_list                     shift and go to state 2
    stmt_list                      shift and go to state 3
    block                          shift and go to state 4
    stmt                           shift and go to state 5
    expr                           shift and go to state 7
    print                          shift and go to state 8
    assignment                     shift and go to state 9
    cond_stmt                      shift and go to state 10
    list                           shift and go to state 16
    tuple                          shift and go to state 17
    if                             shift and go to state 24
    if_else                        shift and go to state 25
    while                          shift and go to state 26

state 1

    (0) S' -> program .



state 2

    (1) program -> block_list .
    (2) block_list -> block_list . stmt_list
    (4) block_list -> block_list . block
    (9) stmt_list -> . stmt_list stmt
    (10) stmt_list -> . stmt
    (11) block -> . LC block_list RC
    (12) block -> . LC RC
    (14) stmt -> . expr SEMICOLON
    (15) stmt -> . print SEMICOLON
    (16) stmt -> . assignment SEMICOLON
    (17) stmt -> . cond_stmt
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (13) print -> . PRINT L_PAREN expr R_PAREN
    (28) assignment -> . expr indexSequenceList EQ expr
    (29) assignment -> . expr EQ expr
    (6) cond_stmt -> . if
    (7) cond_stmt -> . if_else
    (8) cond_stmt -> . while
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN
    (19) if -> . IF L_PAREN expr R_PAREN block
    (18) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (20) while -> . WHILE L_PAREN expr R_PAREN block

    $end            reduce using rule 1 (program -> block_list .)
    LC              shift and go to state 6
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    PRINT           shift and go to state 23
    L_BRACK         shift and go to state 21
    IF              shift and go to state 27
    WHILE           shift and go to state 28

    stmt_list                      shift and go to state 29
    block                          shift and go to state 30
    stmt                           shift and go to state 5
    expr                           shift and go to state 7
    print                          shift and go to state 8
    assignment                     shift and go to state 9
    cond_stmt                      shift and go to state 10
    list                           shift and go to state 16
    tuple                          shift and go to state 17
    if                             shift and go to state 24
    if_else                        shift and go to state 25
    while                          shift and go to state 26

state 3

    (3) block_list -> stmt_list .
    (9) stmt_list -> stmt_list . stmt
    (14) stmt -> . expr SEMICOLON
    (15) stmt -> . print SEMICOLON
    (16) stmt -> . assignment SEMICOLON
    (17) stmt -> . cond_stmt
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (13) print -> . PRINT L_PAREN expr R_PAREN
    (28) assignment -> . expr indexSequenceList EQ expr
    (29) assignment -> . expr EQ expr
    (6) cond_stmt -> . if
    (7) cond_stmt -> . if_else
    (8) cond_stmt -> . while
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN
    (19) if -> . IF L_PAREN expr R_PAREN block
    (18) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (20) while -> . WHILE L_PAREN expr R_PAREN block

  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for HASHTAG resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for L_BRACK resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    LC              reduce using rule 3 (block_list -> stmt_list .)
    $end            reduce using rule 3 (block_list -> stmt_list .)
    RC              reduce using rule 3 (block_list -> stmt_list .)
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    PRINT           shift and go to state 23
    L_BRACK         shift and go to state 21
    IF              shift and go to state 27
    WHILE           shift and go to state 28

  ! INTEGER         [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! FLOAT           [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! STRING          [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! BOOLEAN         [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! VARIABLE        [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! HASHTAG         [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! MINUS           [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! NOT             [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! L_PAREN         [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! PRINT           [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! L_BRACK         [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! IF              [ reduce using rule 3 (block_list -> stmt_list .) ]
  ! WHILE           [ reduce using rule 3 (block_list -> stmt_list .) ]

    stmt                           shift and go to state 31
    expr                           shift and go to state 7
    print                          shift and go to state 8
    assignment                     shift and go to state 9
    cond_stmt                      shift and go to state 10
    list                           shift and go to state 16
    tuple                          shift and go to state 17
    if                             shift and go to state 24
    if_else                        shift and go to state 25
    while                          shift and go to state 26

state 4

    (5) block_list -> block .

    LC              reduce using rule 5 (block_list -> block .)
    INTEGER         reduce using rule 5 (block_list -> block .)
    FLOAT           reduce using rule 5 (block_list -> block .)
    STRING          reduce using rule 5 (block_list -> block .)
    BOOLEAN         reduce using rule 5 (block_list -> block .)
    VARIABLE        reduce using rule 5 (block_list -> block .)
    HASHTAG         reduce using rule 5 (block_list -> block .)
    MINUS           reduce using rule 5 (block_list -> block .)
    NOT             reduce using rule 5 (block_list -> block .)
    L_PAREN         reduce using rule 5 (block_list -> block .)
    PRINT           reduce using rule 5 (block_list -> block .)
    L_BRACK         reduce using rule 5 (block_list -> block .)
    IF              reduce using rule 5 (block_list -> block .)
    WHILE           reduce using rule 5 (block_list -> block .)
    $end            reduce using rule 5 (block_list -> block .)
    RC              reduce using rule 5 (block_list -> block .)


state 5

    (10) stmt_list -> stmt .

    INTEGER         reduce using rule 10 (stmt_list -> stmt .)
    FLOAT           reduce using rule 10 (stmt_list -> stmt .)
    STRING          reduce using rule 10 (stmt_list -> stmt .)
    BOOLEAN         reduce using rule 10 (stmt_list -> stmt .)
    VARIABLE        reduce using rule 10 (stmt_list -> stmt .)
    HASHTAG         reduce using rule 10 (stmt_list -> stmt .)
    MINUS           reduce using rule 10 (stmt_list -> stmt .)
    NOT             reduce using rule 10 (stmt_list -> stmt .)
    L_PAREN         reduce using rule 10 (stmt_list -> stmt .)
    PRINT           reduce using rule 10 (stmt_list -> stmt .)
    L_BRACK         reduce using rule 10 (stmt_list -> stmt .)
    IF              reduce using rule 10 (stmt_list -> stmt .)
    WHILE           reduce using rule 10 (stmt_list -> stmt .)
    LC              reduce using rule 10 (stmt_list -> stmt .)
    $end            reduce using rule 10 (stmt_list -> stmt .)
    RC              reduce using rule 10 (stmt_list -> stmt .)


state 6

    (11) block -> LC . block_list RC
    (12) block -> LC . RC
    (2) block_list -> . block_list stmt_list
    (3) block_list -> . stmt_list
    (4) block_list -> . block_list block
    (5) block_list -> . block
    (9) stmt_list -> . stmt_list stmt
    (10) stmt_list -> . stmt
    (11) block -> . LC block_list RC
    (12) block -> . LC RC
    (14) stmt -> . expr SEMICOLON
    (15) stmt -> . print SEMICOLON
    (16) stmt -> . assignment SEMICOLON
    (17) stmt -> . cond_stmt
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (13) print -> . PRINT L_PAREN expr R_PAREN
    (28) assignment -> . expr indexSequenceList EQ expr
    (29) assignment -> . expr EQ expr
    (6) cond_stmt -> . if
    (7) cond_stmt -> . if_else
    (8) cond_stmt -> . while
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN
    (19) if -> . IF L_PAREN expr R_PAREN block
    (18) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (20) while -> . WHILE L_PAREN expr R_PAREN block

    RC              shift and go to state 33
    LC              shift and go to state 6
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    PRINT           shift and go to state 23
    L_BRACK         shift and go to state 21
    IF              shift and go to state 27
    WHILE           shift and go to state 28

    block_list                     shift and go to state 32
    stmt_list                      shift and go to state 3
    block                          shift and go to state 4
    stmt                           shift and go to state 5
    expr                           shift and go to state 7
    print                          shift and go to state 8
    assignment                     shift and go to state 9
    cond_stmt                      shift and go to state 10
    list                           shift and go to state 16
    tuple                          shift and go to state 17
    if                             shift and go to state 24
    if_else                        shift and go to state 25
    while                          shift and go to state 26

state 7

    (14) stmt -> expr . SEMICOLON
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK
    (28) assignment -> expr . indexSequenceList EQ expr
    (29) assignment -> expr . EQ expr
    (52) indexSequenceList -> . indexSequenceList indexTkn
    (53) indexSequenceList -> . indexTkn
    (54) indexTkn -> . L_BRACK expr R_BRACK

    SEMICOLON       shift and go to state 34
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 52
    EQ              shift and go to state 54

    indexSequenceList              shift and go to state 53
    indexTkn                       shift and go to state 55

state 8

    (15) stmt -> print . SEMICOLON

    SEMICOLON       shift and go to state 56


state 9

    (16) stmt -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 57


state 10

    (17) stmt -> cond_stmt .

    INTEGER         reduce using rule 17 (stmt -> cond_stmt .)
    FLOAT           reduce using rule 17 (stmt -> cond_stmt .)
    STRING          reduce using rule 17 (stmt -> cond_stmt .)
    BOOLEAN         reduce using rule 17 (stmt -> cond_stmt .)
    VARIABLE        reduce using rule 17 (stmt -> cond_stmt .)
    HASHTAG         reduce using rule 17 (stmt -> cond_stmt .)
    MINUS           reduce using rule 17 (stmt -> cond_stmt .)
    NOT             reduce using rule 17 (stmt -> cond_stmt .)
    L_PAREN         reduce using rule 17 (stmt -> cond_stmt .)
    PRINT           reduce using rule 17 (stmt -> cond_stmt .)
    L_BRACK         reduce using rule 17 (stmt -> cond_stmt .)
    IF              reduce using rule 17 (stmt -> cond_stmt .)
    WHILE           reduce using rule 17 (stmt -> cond_stmt .)
    LC              reduce using rule 17 (stmt -> cond_stmt .)
    $end            reduce using rule 17 (stmt -> cond_stmt .)
    RC              reduce using rule 17 (stmt -> cond_stmt .)


state 11

    (21) expr -> INTEGER .

    SEMICOLON       reduce using rule 21 (expr -> INTEGER .)
    POW             reduce using rule 21 (expr -> INTEGER .)
    MULT            reduce using rule 21 (expr -> INTEGER .)
    DIVINT          reduce using rule 21 (expr -> INTEGER .)
    DIV             reduce using rule 21 (expr -> INTEGER .)
    MOD             reduce using rule 21 (expr -> INTEGER .)
    PLUS            reduce using rule 21 (expr -> INTEGER .)
    MINUS           reduce using rule 21 (expr -> INTEGER .)
    AND_ALSO        reduce using rule 21 (expr -> INTEGER .)
    OR_ELSE         reduce using rule 21 (expr -> INTEGER .)
    LTE             reduce using rule 21 (expr -> INTEGER .)
    GTE             reduce using rule 21 (expr -> INTEGER .)
    EQ_EQ           reduce using rule 21 (expr -> INTEGER .)
    NEQ             reduce using rule 21 (expr -> INTEGER .)
    LT              reduce using rule 21 (expr -> INTEGER .)
    GT              reduce using rule 21 (expr -> INTEGER .)
    IN              reduce using rule 21 (expr -> INTEGER .)
    CONS            reduce using rule 21 (expr -> INTEGER .)
    L_BRACK         reduce using rule 21 (expr -> INTEGER .)
    EQ              reduce using rule 21 (expr -> INTEGER .)
    COMMA           reduce using rule 21 (expr -> INTEGER .)
    R_BRACK         reduce using rule 21 (expr -> INTEGER .)
    R_PAREN         reduce using rule 21 (expr -> INTEGER .)


state 12

    (22) expr -> FLOAT .

    SEMICOLON       reduce using rule 22 (expr -> FLOAT .)
    POW             reduce using rule 22 (expr -> FLOAT .)
    MULT            reduce using rule 22 (expr -> FLOAT .)
    DIVINT          reduce using rule 22 (expr -> FLOAT .)
    DIV             reduce using rule 22 (expr -> FLOAT .)
    MOD             reduce using rule 22 (expr -> FLOAT .)
    PLUS            reduce using rule 22 (expr -> FLOAT .)
    MINUS           reduce using rule 22 (expr -> FLOAT .)
    AND_ALSO        reduce using rule 22 (expr -> FLOAT .)
    OR_ELSE         reduce using rule 22 (expr -> FLOAT .)
    LTE             reduce using rule 22 (expr -> FLOAT .)
    GTE             reduce using rule 22 (expr -> FLOAT .)
    EQ_EQ           reduce using rule 22 (expr -> FLOAT .)
    NEQ             reduce using rule 22 (expr -> FLOAT .)
    LT              reduce using rule 22 (expr -> FLOAT .)
    GT              reduce using rule 22 (expr -> FLOAT .)
    IN              reduce using rule 22 (expr -> FLOAT .)
    CONS            reduce using rule 22 (expr -> FLOAT .)
    L_BRACK         reduce using rule 22 (expr -> FLOAT .)
    EQ              reduce using rule 22 (expr -> FLOAT .)
    COMMA           reduce using rule 22 (expr -> FLOAT .)
    R_BRACK         reduce using rule 22 (expr -> FLOAT .)
    R_PAREN         reduce using rule 22 (expr -> FLOAT .)


state 13

    (23) expr -> STRING .

    SEMICOLON       reduce using rule 23 (expr -> STRING .)
    POW             reduce using rule 23 (expr -> STRING .)
    MULT            reduce using rule 23 (expr -> STRING .)
    DIVINT          reduce using rule 23 (expr -> STRING .)
    DIV             reduce using rule 23 (expr -> STRING .)
    MOD             reduce using rule 23 (expr -> STRING .)
    PLUS            reduce using rule 23 (expr -> STRING .)
    MINUS           reduce using rule 23 (expr -> STRING .)
    AND_ALSO        reduce using rule 23 (expr -> STRING .)
    OR_ELSE         reduce using rule 23 (expr -> STRING .)
    LTE             reduce using rule 23 (expr -> STRING .)
    GTE             reduce using rule 23 (expr -> STRING .)
    EQ_EQ           reduce using rule 23 (expr -> STRING .)
    NEQ             reduce using rule 23 (expr -> STRING .)
    LT              reduce using rule 23 (expr -> STRING .)
    GT              reduce using rule 23 (expr -> STRING .)
    IN              reduce using rule 23 (expr -> STRING .)
    CONS            reduce using rule 23 (expr -> STRING .)
    L_BRACK         reduce using rule 23 (expr -> STRING .)
    EQ              reduce using rule 23 (expr -> STRING .)
    COMMA           reduce using rule 23 (expr -> STRING .)
    R_BRACK         reduce using rule 23 (expr -> STRING .)
    R_PAREN         reduce using rule 23 (expr -> STRING .)


state 14

    (24) expr -> BOOLEAN .

    SEMICOLON       reduce using rule 24 (expr -> BOOLEAN .)
    POW             reduce using rule 24 (expr -> BOOLEAN .)
    MULT            reduce using rule 24 (expr -> BOOLEAN .)
    DIVINT          reduce using rule 24 (expr -> BOOLEAN .)
    DIV             reduce using rule 24 (expr -> BOOLEAN .)
    MOD             reduce using rule 24 (expr -> BOOLEAN .)
    PLUS            reduce using rule 24 (expr -> BOOLEAN .)
    MINUS           reduce using rule 24 (expr -> BOOLEAN .)
    AND_ALSO        reduce using rule 24 (expr -> BOOLEAN .)
    OR_ELSE         reduce using rule 24 (expr -> BOOLEAN .)
    LTE             reduce using rule 24 (expr -> BOOLEAN .)
    GTE             reduce using rule 24 (expr -> BOOLEAN .)
    EQ_EQ           reduce using rule 24 (expr -> BOOLEAN .)
    NEQ             reduce using rule 24 (expr -> BOOLEAN .)
    LT              reduce using rule 24 (expr -> BOOLEAN .)
    GT              reduce using rule 24 (expr -> BOOLEAN .)
    IN              reduce using rule 24 (expr -> BOOLEAN .)
    CONS            reduce using rule 24 (expr -> BOOLEAN .)
    L_BRACK         reduce using rule 24 (expr -> BOOLEAN .)
    EQ              reduce using rule 24 (expr -> BOOLEAN .)
    COMMA           reduce using rule 24 (expr -> BOOLEAN .)
    R_BRACK         reduce using rule 24 (expr -> BOOLEAN .)
    R_PAREN         reduce using rule 24 (expr -> BOOLEAN .)


state 15

    (25) expr -> VARIABLE .

    SEMICOLON       reduce using rule 25 (expr -> VARIABLE .)
    POW             reduce using rule 25 (expr -> VARIABLE .)
    MULT            reduce using rule 25 (expr -> VARIABLE .)
    DIVINT          reduce using rule 25 (expr -> VARIABLE .)
    DIV             reduce using rule 25 (expr -> VARIABLE .)
    MOD             reduce using rule 25 (expr -> VARIABLE .)
    PLUS            reduce using rule 25 (expr -> VARIABLE .)
    MINUS           reduce using rule 25 (expr -> VARIABLE .)
    AND_ALSO        reduce using rule 25 (expr -> VARIABLE .)
    OR_ELSE         reduce using rule 25 (expr -> VARIABLE .)
    LTE             reduce using rule 25 (expr -> VARIABLE .)
    GTE             reduce using rule 25 (expr -> VARIABLE .)
    EQ_EQ           reduce using rule 25 (expr -> VARIABLE .)
    NEQ             reduce using rule 25 (expr -> VARIABLE .)
    LT              reduce using rule 25 (expr -> VARIABLE .)
    GT              reduce using rule 25 (expr -> VARIABLE .)
    IN              reduce using rule 25 (expr -> VARIABLE .)
    CONS            reduce using rule 25 (expr -> VARIABLE .)
    L_BRACK         reduce using rule 25 (expr -> VARIABLE .)
    EQ              reduce using rule 25 (expr -> VARIABLE .)
    COMMA           reduce using rule 25 (expr -> VARIABLE .)
    R_BRACK         reduce using rule 25 (expr -> VARIABLE .)
    R_PAREN         reduce using rule 25 (expr -> VARIABLE .)


state 16

    (26) expr -> list .

    SEMICOLON       reduce using rule 26 (expr -> list .)
    POW             reduce using rule 26 (expr -> list .)
    MULT            reduce using rule 26 (expr -> list .)
    DIVINT          reduce using rule 26 (expr -> list .)
    DIV             reduce using rule 26 (expr -> list .)
    MOD             reduce using rule 26 (expr -> list .)
    PLUS            reduce using rule 26 (expr -> list .)
    MINUS           reduce using rule 26 (expr -> list .)
    AND_ALSO        reduce using rule 26 (expr -> list .)
    OR_ELSE         reduce using rule 26 (expr -> list .)
    LTE             reduce using rule 26 (expr -> list .)
    GTE             reduce using rule 26 (expr -> list .)
    EQ_EQ           reduce using rule 26 (expr -> list .)
    NEQ             reduce using rule 26 (expr -> list .)
    LT              reduce using rule 26 (expr -> list .)
    GT              reduce using rule 26 (expr -> list .)
    IN              reduce using rule 26 (expr -> list .)
    CONS            reduce using rule 26 (expr -> list .)
    L_BRACK         reduce using rule 26 (expr -> list .)
    EQ              reduce using rule 26 (expr -> list .)
    COMMA           reduce using rule 26 (expr -> list .)
    R_BRACK         reduce using rule 26 (expr -> list .)
    R_PAREN         reduce using rule 26 (expr -> list .)


state 17

    (27) expr -> tuple .

    SEMICOLON       reduce using rule 27 (expr -> tuple .)
    POW             reduce using rule 27 (expr -> tuple .)
    MULT            reduce using rule 27 (expr -> tuple .)
    DIVINT          reduce using rule 27 (expr -> tuple .)
    DIV             reduce using rule 27 (expr -> tuple .)
    MOD             reduce using rule 27 (expr -> tuple .)
    PLUS            reduce using rule 27 (expr -> tuple .)
    MINUS           reduce using rule 27 (expr -> tuple .)
    AND_ALSO        reduce using rule 27 (expr -> tuple .)
    OR_ELSE         reduce using rule 27 (expr -> tuple .)
    LTE             reduce using rule 27 (expr -> tuple .)
    GTE             reduce using rule 27 (expr -> tuple .)
    EQ_EQ           reduce using rule 27 (expr -> tuple .)
    NEQ             reduce using rule 27 (expr -> tuple .)
    LT              reduce using rule 27 (expr -> tuple .)
    GT              reduce using rule 27 (expr -> tuple .)
    IN              reduce using rule 27 (expr -> tuple .)
    CONS            reduce using rule 27 (expr -> tuple .)
    L_BRACK         reduce using rule 27 (expr -> tuple .)
    EQ              reduce using rule 27 (expr -> tuple .)
    COMMA           reduce using rule 27 (expr -> tuple .)
    R_BRACK         reduce using rule 27 (expr -> tuple .)
    R_PAREN         reduce using rule 27 (expr -> tuple .)


state 18

    (30) expr -> HASHTAG . INTEGER expr

    INTEGER         shift and go to state 58


state 19

    (40) expr -> MINUS . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 59
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 20

    (51) expr -> NOT . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 60
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 21

    (56) list -> L_BRACK . sequence R_BRACK
    (57) list -> L_BRACK . R_BRACK
    (58) sequence -> . expr COMMA sequence
    (59) sequence -> . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    R_BRACK         shift and go to state 62
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    sequence                       shift and go to state 61
    expr                           shift and go to state 63
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 22

    (60) expr -> L_PAREN . expr R_PAREN
    (31) tuple -> L_PAREN . sequence R_PAREN
    (32) tuple -> L_PAREN . R_PAREN
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (58) sequence -> . expr COMMA sequence
    (59) sequence -> . expr
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    R_PAREN         shift and go to state 65
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 64
    sequence                       shift and go to state 66
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 23

    (13) print -> PRINT . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 67


state 24

    (6) cond_stmt -> if .

    INTEGER         reduce using rule 6 (cond_stmt -> if .)
    FLOAT           reduce using rule 6 (cond_stmt -> if .)
    STRING          reduce using rule 6 (cond_stmt -> if .)
    BOOLEAN         reduce using rule 6 (cond_stmt -> if .)
    VARIABLE        reduce using rule 6 (cond_stmt -> if .)
    HASHTAG         reduce using rule 6 (cond_stmt -> if .)
    MINUS           reduce using rule 6 (cond_stmt -> if .)
    NOT             reduce using rule 6 (cond_stmt -> if .)
    L_PAREN         reduce using rule 6 (cond_stmt -> if .)
    PRINT           reduce using rule 6 (cond_stmt -> if .)
    L_BRACK         reduce using rule 6 (cond_stmt -> if .)
    IF              reduce using rule 6 (cond_stmt -> if .)
    WHILE           reduce using rule 6 (cond_stmt -> if .)
    LC              reduce using rule 6 (cond_stmt -> if .)
    $end            reduce using rule 6 (cond_stmt -> if .)
    RC              reduce using rule 6 (cond_stmt -> if .)


state 25

    (7) cond_stmt -> if_else .

    INTEGER         reduce using rule 7 (cond_stmt -> if_else .)
    FLOAT           reduce using rule 7 (cond_stmt -> if_else .)
    STRING          reduce using rule 7 (cond_stmt -> if_else .)
    BOOLEAN         reduce using rule 7 (cond_stmt -> if_else .)
    VARIABLE        reduce using rule 7 (cond_stmt -> if_else .)
    HASHTAG         reduce using rule 7 (cond_stmt -> if_else .)
    MINUS           reduce using rule 7 (cond_stmt -> if_else .)
    NOT             reduce using rule 7 (cond_stmt -> if_else .)
    L_PAREN         reduce using rule 7 (cond_stmt -> if_else .)
    PRINT           reduce using rule 7 (cond_stmt -> if_else .)
    L_BRACK         reduce using rule 7 (cond_stmt -> if_else .)
    IF              reduce using rule 7 (cond_stmt -> if_else .)
    WHILE           reduce using rule 7 (cond_stmt -> if_else .)
    LC              reduce using rule 7 (cond_stmt -> if_else .)
    $end            reduce using rule 7 (cond_stmt -> if_else .)
    RC              reduce using rule 7 (cond_stmt -> if_else .)


state 26

    (8) cond_stmt -> while .

    INTEGER         reduce using rule 8 (cond_stmt -> while .)
    FLOAT           reduce using rule 8 (cond_stmt -> while .)
    STRING          reduce using rule 8 (cond_stmt -> while .)
    BOOLEAN         reduce using rule 8 (cond_stmt -> while .)
    VARIABLE        reduce using rule 8 (cond_stmt -> while .)
    HASHTAG         reduce using rule 8 (cond_stmt -> while .)
    MINUS           reduce using rule 8 (cond_stmt -> while .)
    NOT             reduce using rule 8 (cond_stmt -> while .)
    L_PAREN         reduce using rule 8 (cond_stmt -> while .)
    PRINT           reduce using rule 8 (cond_stmt -> while .)
    L_BRACK         reduce using rule 8 (cond_stmt -> while .)
    IF              reduce using rule 8 (cond_stmt -> while .)
    WHILE           reduce using rule 8 (cond_stmt -> while .)
    LC              reduce using rule 8 (cond_stmt -> while .)
    $end            reduce using rule 8 (cond_stmt -> while .)
    RC              reduce using rule 8 (cond_stmt -> while .)


state 27

    (19) if -> IF . L_PAREN expr R_PAREN block
    (18) if_else -> IF . L_PAREN expr R_PAREN block ELSE block

    L_PAREN         shift and go to state 68


state 28

    (20) while -> WHILE . L_PAREN expr R_PAREN block

    L_PAREN         shift and go to state 69


state 29

    (2) block_list -> block_list stmt_list .
    (9) stmt_list -> stmt_list . stmt
    (14) stmt -> . expr SEMICOLON
    (15) stmt -> . print SEMICOLON
    (16) stmt -> . assignment SEMICOLON
    (17) stmt -> . cond_stmt
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (13) print -> . PRINT L_PAREN expr R_PAREN
    (28) assignment -> . expr indexSequenceList EQ expr
    (29) assignment -> . expr EQ expr
    (6) cond_stmt -> . if
    (7) cond_stmt -> . if_else
    (8) cond_stmt -> . while
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN
    (19) if -> . IF L_PAREN expr R_PAREN block
    (18) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (20) while -> . WHILE L_PAREN expr R_PAREN block

  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for HASHTAG resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for L_PAREN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for L_BRACK resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    LC              reduce using rule 2 (block_list -> block_list stmt_list .)
    $end            reduce using rule 2 (block_list -> block_list stmt_list .)
    RC              reduce using rule 2 (block_list -> block_list stmt_list .)
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    PRINT           shift and go to state 23
    L_BRACK         shift and go to state 21
    IF              shift and go to state 27
    WHILE           shift and go to state 28

  ! INTEGER         [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! FLOAT           [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! STRING          [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! BOOLEAN         [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! VARIABLE        [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! HASHTAG         [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! MINUS           [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! NOT             [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! L_PAREN         [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! PRINT           [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! L_BRACK         [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! IF              [ reduce using rule 2 (block_list -> block_list stmt_list .) ]
  ! WHILE           [ reduce using rule 2 (block_list -> block_list stmt_list .) ]

    stmt                           shift and go to state 31
    expr                           shift and go to state 7
    print                          shift and go to state 8
    assignment                     shift and go to state 9
    cond_stmt                      shift and go to state 10
    list                           shift and go to state 16
    tuple                          shift and go to state 17
    if                             shift and go to state 24
    if_else                        shift and go to state 25
    while                          shift and go to state 26

state 30

    (4) block_list -> block_list block .

    LC              reduce using rule 4 (block_list -> block_list block .)
    INTEGER         reduce using rule 4 (block_list -> block_list block .)
    FLOAT           reduce using rule 4 (block_list -> block_list block .)
    STRING          reduce using rule 4 (block_list -> block_list block .)
    BOOLEAN         reduce using rule 4 (block_list -> block_list block .)
    VARIABLE        reduce using rule 4 (block_list -> block_list block .)
    HASHTAG         reduce using rule 4 (block_list -> block_list block .)
    MINUS           reduce using rule 4 (block_list -> block_list block .)
    NOT             reduce using rule 4 (block_list -> block_list block .)
    L_PAREN         reduce using rule 4 (block_list -> block_list block .)
    PRINT           reduce using rule 4 (block_list -> block_list block .)
    L_BRACK         reduce using rule 4 (block_list -> block_list block .)
    IF              reduce using rule 4 (block_list -> block_list block .)
    WHILE           reduce using rule 4 (block_list -> block_list block .)
    $end            reduce using rule 4 (block_list -> block_list block .)
    RC              reduce using rule 4 (block_list -> block_list block .)


state 31

    (9) stmt_list -> stmt_list stmt .

    INTEGER         reduce using rule 9 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 9 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 9 (stmt_list -> stmt_list stmt .)
    BOOLEAN         reduce using rule 9 (stmt_list -> stmt_list stmt .)
    VARIABLE        reduce using rule 9 (stmt_list -> stmt_list stmt .)
    HASHTAG         reduce using rule 9 (stmt_list -> stmt_list stmt .)
    MINUS           reduce using rule 9 (stmt_list -> stmt_list stmt .)
    NOT             reduce using rule 9 (stmt_list -> stmt_list stmt .)
    L_PAREN         reduce using rule 9 (stmt_list -> stmt_list stmt .)
    PRINT           reduce using rule 9 (stmt_list -> stmt_list stmt .)
    L_BRACK         reduce using rule 9 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 9 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 9 (stmt_list -> stmt_list stmt .)
    LC              reduce using rule 9 (stmt_list -> stmt_list stmt .)
    $end            reduce using rule 9 (stmt_list -> stmt_list stmt .)
    RC              reduce using rule 9 (stmt_list -> stmt_list stmt .)


state 32

    (11) block -> LC block_list . RC
    (2) block_list -> block_list . stmt_list
    (4) block_list -> block_list . block
    (9) stmt_list -> . stmt_list stmt
    (10) stmt_list -> . stmt
    (11) block -> . LC block_list RC
    (12) block -> . LC RC
    (14) stmt -> . expr SEMICOLON
    (15) stmt -> . print SEMICOLON
    (16) stmt -> . assignment SEMICOLON
    (17) stmt -> . cond_stmt
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (13) print -> . PRINT L_PAREN expr R_PAREN
    (28) assignment -> . expr indexSequenceList EQ expr
    (29) assignment -> . expr EQ expr
    (6) cond_stmt -> . if
    (7) cond_stmt -> . if_else
    (8) cond_stmt -> . while
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN
    (19) if -> . IF L_PAREN expr R_PAREN block
    (18) if_else -> . IF L_PAREN expr R_PAREN block ELSE block
    (20) while -> . WHILE L_PAREN expr R_PAREN block

    RC              shift and go to state 70
    LC              shift and go to state 6
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    PRINT           shift and go to state 23
    L_BRACK         shift and go to state 21
    IF              shift and go to state 27
    WHILE           shift and go to state 28

    stmt_list                      shift and go to state 29
    block                          shift and go to state 30
    stmt                           shift and go to state 5
    expr                           shift and go to state 7
    print                          shift and go to state 8
    assignment                     shift and go to state 9
    cond_stmt                      shift and go to state 10
    list                           shift and go to state 16
    tuple                          shift and go to state 17
    if                             shift and go to state 24
    if_else                        shift and go to state 25
    while                          shift and go to state 26

state 33

    (12) block -> LC RC .

    LC              reduce using rule 12 (block -> LC RC .)
    INTEGER         reduce using rule 12 (block -> LC RC .)
    FLOAT           reduce using rule 12 (block -> LC RC .)
    STRING          reduce using rule 12 (block -> LC RC .)
    BOOLEAN         reduce using rule 12 (block -> LC RC .)
    VARIABLE        reduce using rule 12 (block -> LC RC .)
    HASHTAG         reduce using rule 12 (block -> LC RC .)
    MINUS           reduce using rule 12 (block -> LC RC .)
    NOT             reduce using rule 12 (block -> LC RC .)
    L_PAREN         reduce using rule 12 (block -> LC RC .)
    PRINT           reduce using rule 12 (block -> LC RC .)
    L_BRACK         reduce using rule 12 (block -> LC RC .)
    IF              reduce using rule 12 (block -> LC RC .)
    WHILE           reduce using rule 12 (block -> LC RC .)
    $end            reduce using rule 12 (block -> LC RC .)
    RC              reduce using rule 12 (block -> LC RC .)
    ELSE            reduce using rule 12 (block -> LC RC .)


state 34

    (14) stmt -> expr SEMICOLON .

    INTEGER         reduce using rule 14 (stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 14 (stmt -> expr SEMICOLON .)
    STRING          reduce using rule 14 (stmt -> expr SEMICOLON .)
    BOOLEAN         reduce using rule 14 (stmt -> expr SEMICOLON .)
    VARIABLE        reduce using rule 14 (stmt -> expr SEMICOLON .)
    HASHTAG         reduce using rule 14 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 14 (stmt -> expr SEMICOLON .)
    NOT             reduce using rule 14 (stmt -> expr SEMICOLON .)
    L_PAREN         reduce using rule 14 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 14 (stmt -> expr SEMICOLON .)
    L_BRACK         reduce using rule 14 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 14 (stmt -> expr SEMICOLON .)
    WHILE           reduce using rule 14 (stmt -> expr SEMICOLON .)
    LC              reduce using rule 14 (stmt -> expr SEMICOLON .)
    $end            reduce using rule 14 (stmt -> expr SEMICOLON .)
    RC              reduce using rule 14 (stmt -> expr SEMICOLON .)


state 35

    (33) expr -> expr POW . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 71
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 36

    (34) expr -> expr MULT . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 72
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 37

    (35) expr -> expr DIVINT . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 73
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 38

    (36) expr -> expr DIV . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 74
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 39

    (37) expr -> expr MOD . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 75
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 40

    (38) expr -> expr PLUS . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 76
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 41

    (39) expr -> expr MINUS . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 77
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 42

    (41) expr -> expr AND_ALSO . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 78
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 43

    (42) expr -> expr OR_ELSE . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 79
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 44

    (43) expr -> expr LTE . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 80
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 45

    (44) expr -> expr GTE . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 81
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 46

    (45) expr -> expr EQ_EQ . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 82
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 47

    (46) expr -> expr NEQ . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 83
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 48

    (47) expr -> expr LT . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 84
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 49

    (48) expr -> expr GT . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 85
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 50

    (49) expr -> expr IN . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 86
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 51

    (50) expr -> expr CONS . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 87
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 52

    (55) expr -> expr L_BRACK . expr R_BRACK
    (54) indexTkn -> L_BRACK . expr R_BRACK
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 88
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 53

    (28) assignment -> expr indexSequenceList . EQ expr
    (52) indexSequenceList -> indexSequenceList . indexTkn
    (54) indexTkn -> . L_BRACK expr R_BRACK

    EQ              shift and go to state 89
    L_BRACK         shift and go to state 91

    indexTkn                       shift and go to state 90

state 54

    (29) assignment -> expr EQ . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 92
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 55

    (53) indexSequenceList -> indexTkn .

    EQ              reduce using rule 53 (indexSequenceList -> indexTkn .)
    L_BRACK         reduce using rule 53 (indexSequenceList -> indexTkn .)


state 56

    (15) stmt -> print SEMICOLON .

    INTEGER         reduce using rule 15 (stmt -> print SEMICOLON .)
    FLOAT           reduce using rule 15 (stmt -> print SEMICOLON .)
    STRING          reduce using rule 15 (stmt -> print SEMICOLON .)
    BOOLEAN         reduce using rule 15 (stmt -> print SEMICOLON .)
    VARIABLE        reduce using rule 15 (stmt -> print SEMICOLON .)
    HASHTAG         reduce using rule 15 (stmt -> print SEMICOLON .)
    MINUS           reduce using rule 15 (stmt -> print SEMICOLON .)
    NOT             reduce using rule 15 (stmt -> print SEMICOLON .)
    L_PAREN         reduce using rule 15 (stmt -> print SEMICOLON .)
    PRINT           reduce using rule 15 (stmt -> print SEMICOLON .)
    L_BRACK         reduce using rule 15 (stmt -> print SEMICOLON .)
    IF              reduce using rule 15 (stmt -> print SEMICOLON .)
    WHILE           reduce using rule 15 (stmt -> print SEMICOLON .)
    LC              reduce using rule 15 (stmt -> print SEMICOLON .)
    $end            reduce using rule 15 (stmt -> print SEMICOLON .)
    RC              reduce using rule 15 (stmt -> print SEMICOLON .)


state 57

    (16) stmt -> assignment SEMICOLON .

    INTEGER         reduce using rule 16 (stmt -> assignment SEMICOLON .)
    FLOAT           reduce using rule 16 (stmt -> assignment SEMICOLON .)
    STRING          reduce using rule 16 (stmt -> assignment SEMICOLON .)
    BOOLEAN         reduce using rule 16 (stmt -> assignment SEMICOLON .)
    VARIABLE        reduce using rule 16 (stmt -> assignment SEMICOLON .)
    HASHTAG         reduce using rule 16 (stmt -> assignment SEMICOLON .)
    MINUS           reduce using rule 16 (stmt -> assignment SEMICOLON .)
    NOT             reduce using rule 16 (stmt -> assignment SEMICOLON .)
    L_PAREN         reduce using rule 16 (stmt -> assignment SEMICOLON .)
    PRINT           reduce using rule 16 (stmt -> assignment SEMICOLON .)
    L_BRACK         reduce using rule 16 (stmt -> assignment SEMICOLON .)
    IF              reduce using rule 16 (stmt -> assignment SEMICOLON .)
    WHILE           reduce using rule 16 (stmt -> assignment SEMICOLON .)
    LC              reduce using rule 16 (stmt -> assignment SEMICOLON .)
    $end            reduce using rule 16 (stmt -> assignment SEMICOLON .)
    RC              reduce using rule 16 (stmt -> assignment SEMICOLON .)


state 58

    (30) expr -> HASHTAG INTEGER . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 93
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 59

    (40) expr -> MINUS expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 40 (expr -> MINUS expr .)
    MULT            reduce using rule 40 (expr -> MINUS expr .)
    DIVINT          reduce using rule 40 (expr -> MINUS expr .)
    DIV             reduce using rule 40 (expr -> MINUS expr .)
    MOD             reduce using rule 40 (expr -> MINUS expr .)
    PLUS            reduce using rule 40 (expr -> MINUS expr .)
    MINUS           reduce using rule 40 (expr -> MINUS expr .)
    AND_ALSO        reduce using rule 40 (expr -> MINUS expr .)
    OR_ELSE         reduce using rule 40 (expr -> MINUS expr .)
    LTE             reduce using rule 40 (expr -> MINUS expr .)
    GTE             reduce using rule 40 (expr -> MINUS expr .)
    EQ_EQ           reduce using rule 40 (expr -> MINUS expr .)
    NEQ             reduce using rule 40 (expr -> MINUS expr .)
    LT              reduce using rule 40 (expr -> MINUS expr .)
    GT              reduce using rule 40 (expr -> MINUS expr .)
    IN              reduce using rule 40 (expr -> MINUS expr .)
    CONS            reduce using rule 40 (expr -> MINUS expr .)
    EQ              reduce using rule 40 (expr -> MINUS expr .)
    COMMA           reduce using rule 40 (expr -> MINUS expr .)
    R_BRACK         reduce using rule 40 (expr -> MINUS expr .)
    R_PAREN         reduce using rule 40 (expr -> MINUS expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 40 (expr -> MINUS expr .) ]
  ! L_BRACK         [ reduce using rule 40 (expr -> MINUS expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 60

    (51) expr -> NOT expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 51 (expr -> NOT expr .)
    MULT            reduce using rule 51 (expr -> NOT expr .)
    DIVINT          reduce using rule 51 (expr -> NOT expr .)
    DIV             reduce using rule 51 (expr -> NOT expr .)
    MOD             reduce using rule 51 (expr -> NOT expr .)
    PLUS            reduce using rule 51 (expr -> NOT expr .)
    MINUS           reduce using rule 51 (expr -> NOT expr .)
    AND_ALSO        reduce using rule 51 (expr -> NOT expr .)
    OR_ELSE         reduce using rule 51 (expr -> NOT expr .)
    LTE             reduce using rule 51 (expr -> NOT expr .)
    GTE             reduce using rule 51 (expr -> NOT expr .)
    EQ_EQ           reduce using rule 51 (expr -> NOT expr .)
    NEQ             reduce using rule 51 (expr -> NOT expr .)
    LT              reduce using rule 51 (expr -> NOT expr .)
    GT              reduce using rule 51 (expr -> NOT expr .)
    IN              reduce using rule 51 (expr -> NOT expr .)
    CONS            reduce using rule 51 (expr -> NOT expr .)
    EQ              reduce using rule 51 (expr -> NOT expr .)
    COMMA           reduce using rule 51 (expr -> NOT expr .)
    R_BRACK         reduce using rule 51 (expr -> NOT expr .)
    R_PAREN         reduce using rule 51 (expr -> NOT expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 51 (expr -> NOT expr .) ]
  ! L_BRACK         [ reduce using rule 51 (expr -> NOT expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 61

    (56) list -> L_BRACK sequence . R_BRACK

    R_BRACK         shift and go to state 95


state 62

    (57) list -> L_BRACK R_BRACK .

    SEMICOLON       reduce using rule 57 (list -> L_BRACK R_BRACK .)
    POW             reduce using rule 57 (list -> L_BRACK R_BRACK .)
    MULT            reduce using rule 57 (list -> L_BRACK R_BRACK .)
    DIVINT          reduce using rule 57 (list -> L_BRACK R_BRACK .)
    DIV             reduce using rule 57 (list -> L_BRACK R_BRACK .)
    MOD             reduce using rule 57 (list -> L_BRACK R_BRACK .)
    PLUS            reduce using rule 57 (list -> L_BRACK R_BRACK .)
    MINUS           reduce using rule 57 (list -> L_BRACK R_BRACK .)
    AND_ALSO        reduce using rule 57 (list -> L_BRACK R_BRACK .)
    OR_ELSE         reduce using rule 57 (list -> L_BRACK R_BRACK .)
    LTE             reduce using rule 57 (list -> L_BRACK R_BRACK .)
    GTE             reduce using rule 57 (list -> L_BRACK R_BRACK .)
    EQ_EQ           reduce using rule 57 (list -> L_BRACK R_BRACK .)
    NEQ             reduce using rule 57 (list -> L_BRACK R_BRACK .)
    LT              reduce using rule 57 (list -> L_BRACK R_BRACK .)
    GT              reduce using rule 57 (list -> L_BRACK R_BRACK .)
    IN              reduce using rule 57 (list -> L_BRACK R_BRACK .)
    CONS            reduce using rule 57 (list -> L_BRACK R_BRACK .)
    L_BRACK         reduce using rule 57 (list -> L_BRACK R_BRACK .)
    EQ              reduce using rule 57 (list -> L_BRACK R_BRACK .)
    COMMA           reduce using rule 57 (list -> L_BRACK R_BRACK .)
    R_BRACK         reduce using rule 57 (list -> L_BRACK R_BRACK .)
    R_PAREN         reduce using rule 57 (list -> L_BRACK R_BRACK .)


state 63

    (58) sequence -> expr . COMMA sequence
    (59) sequence -> expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    COMMA           shift and go to state 96
    R_BRACK         reduce using rule 59 (sequence -> expr .)
    R_PAREN         reduce using rule 59 (sequence -> expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 64

    (60) expr -> L_PAREN expr . R_PAREN
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK
    (58) sequence -> expr . COMMA sequence
    (59) sequence -> expr .

  ! shift/reduce conflict for R_PAREN resolved as shift
    R_PAREN         shift and go to state 97
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94
    COMMA           shift and go to state 96

  ! R_PAREN         [ reduce using rule 59 (sequence -> expr .) ]


state 65

    (32) tuple -> L_PAREN R_PAREN .

    SEMICOLON       reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    POW             reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    MULT            reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    DIVINT          reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    DIV             reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    MOD             reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    PLUS            reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    MINUS           reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    AND_ALSO        reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    OR_ELSE         reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    LTE             reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    GTE             reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    EQ_EQ           reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    NEQ             reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    LT              reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    GT              reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    IN              reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    CONS            reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    L_BRACK         reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    EQ              reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    COMMA           reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    R_BRACK         reduce using rule 32 (tuple -> L_PAREN R_PAREN .)
    R_PAREN         reduce using rule 32 (tuple -> L_PAREN R_PAREN .)


state 66

    (31) tuple -> L_PAREN sequence . R_PAREN

    R_PAREN         shift and go to state 98


state 67

    (13) print -> PRINT L_PAREN . expr R_PAREN
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 99
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 68

    (19) if -> IF L_PAREN . expr R_PAREN block
    (18) if_else -> IF L_PAREN . expr R_PAREN block ELSE block
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 100
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 69

    (20) while -> WHILE L_PAREN . expr R_PAREN block
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 101
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 70

    (11) block -> LC block_list RC .

    LC              reduce using rule 11 (block -> LC block_list RC .)
    INTEGER         reduce using rule 11 (block -> LC block_list RC .)
    FLOAT           reduce using rule 11 (block -> LC block_list RC .)
    STRING          reduce using rule 11 (block -> LC block_list RC .)
    BOOLEAN         reduce using rule 11 (block -> LC block_list RC .)
    VARIABLE        reduce using rule 11 (block -> LC block_list RC .)
    HASHTAG         reduce using rule 11 (block -> LC block_list RC .)
    MINUS           reduce using rule 11 (block -> LC block_list RC .)
    NOT             reduce using rule 11 (block -> LC block_list RC .)
    L_PAREN         reduce using rule 11 (block -> LC block_list RC .)
    PRINT           reduce using rule 11 (block -> LC block_list RC .)
    L_BRACK         reduce using rule 11 (block -> LC block_list RC .)
    IF              reduce using rule 11 (block -> LC block_list RC .)
    WHILE           reduce using rule 11 (block -> LC block_list RC .)
    $end            reduce using rule 11 (block -> LC block_list RC .)
    RC              reduce using rule 11 (block -> LC block_list RC .)
    ELSE            reduce using rule 11 (block -> LC block_list RC .)


state 71

    (33) expr -> expr POW expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 33 (expr -> expr POW expr .)
    MULT            reduce using rule 33 (expr -> expr POW expr .)
    DIVINT          reduce using rule 33 (expr -> expr POW expr .)
    DIV             reduce using rule 33 (expr -> expr POW expr .)
    MOD             reduce using rule 33 (expr -> expr POW expr .)
    PLUS            reduce using rule 33 (expr -> expr POW expr .)
    MINUS           reduce using rule 33 (expr -> expr POW expr .)
    AND_ALSO        reduce using rule 33 (expr -> expr POW expr .)
    OR_ELSE         reduce using rule 33 (expr -> expr POW expr .)
    LTE             reduce using rule 33 (expr -> expr POW expr .)
    GTE             reduce using rule 33 (expr -> expr POW expr .)
    EQ_EQ           reduce using rule 33 (expr -> expr POW expr .)
    NEQ             reduce using rule 33 (expr -> expr POW expr .)
    LT              reduce using rule 33 (expr -> expr POW expr .)
    GT              reduce using rule 33 (expr -> expr POW expr .)
    IN              reduce using rule 33 (expr -> expr POW expr .)
    CONS            reduce using rule 33 (expr -> expr POW expr .)
    EQ              reduce using rule 33 (expr -> expr POW expr .)
    COMMA           reduce using rule 33 (expr -> expr POW expr .)
    R_BRACK         reduce using rule 33 (expr -> expr POW expr .)
    R_PAREN         reduce using rule 33 (expr -> expr POW expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 33 (expr -> expr POW expr .) ]
  ! L_BRACK         [ reduce using rule 33 (expr -> expr POW expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 72

    (34) expr -> expr MULT expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 34 (expr -> expr MULT expr .)
    MULT            reduce using rule 34 (expr -> expr MULT expr .)
    DIVINT          reduce using rule 34 (expr -> expr MULT expr .)
    DIV             reduce using rule 34 (expr -> expr MULT expr .)
    MOD             reduce using rule 34 (expr -> expr MULT expr .)
    PLUS            reduce using rule 34 (expr -> expr MULT expr .)
    MINUS           reduce using rule 34 (expr -> expr MULT expr .)
    AND_ALSO        reduce using rule 34 (expr -> expr MULT expr .)
    OR_ELSE         reduce using rule 34 (expr -> expr MULT expr .)
    LTE             reduce using rule 34 (expr -> expr MULT expr .)
    GTE             reduce using rule 34 (expr -> expr MULT expr .)
    EQ_EQ           reduce using rule 34 (expr -> expr MULT expr .)
    NEQ             reduce using rule 34 (expr -> expr MULT expr .)
    LT              reduce using rule 34 (expr -> expr MULT expr .)
    GT              reduce using rule 34 (expr -> expr MULT expr .)
    IN              reduce using rule 34 (expr -> expr MULT expr .)
    CONS            reduce using rule 34 (expr -> expr MULT expr .)
    EQ              reduce using rule 34 (expr -> expr MULT expr .)
    COMMA           reduce using rule 34 (expr -> expr MULT expr .)
    R_BRACK         reduce using rule 34 (expr -> expr MULT expr .)
    R_PAREN         reduce using rule 34 (expr -> expr MULT expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 34 (expr -> expr MULT expr .) ]
  ! L_BRACK         [ reduce using rule 34 (expr -> expr MULT expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 73

    (35) expr -> expr DIVINT expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 35 (expr -> expr DIVINT expr .)
    MULT            reduce using rule 35 (expr -> expr DIVINT expr .)
    DIVINT          reduce using rule 35 (expr -> expr DIVINT expr .)
    DIV             reduce using rule 35 (expr -> expr DIVINT expr .)
    MOD             reduce using rule 35 (expr -> expr DIVINT expr .)
    PLUS            reduce using rule 35 (expr -> expr DIVINT expr .)
    MINUS           reduce using rule 35 (expr -> expr DIVINT expr .)
    AND_ALSO        reduce using rule 35 (expr -> expr DIVINT expr .)
    OR_ELSE         reduce using rule 35 (expr -> expr DIVINT expr .)
    LTE             reduce using rule 35 (expr -> expr DIVINT expr .)
    GTE             reduce using rule 35 (expr -> expr DIVINT expr .)
    EQ_EQ           reduce using rule 35 (expr -> expr DIVINT expr .)
    NEQ             reduce using rule 35 (expr -> expr DIVINT expr .)
    LT              reduce using rule 35 (expr -> expr DIVINT expr .)
    GT              reduce using rule 35 (expr -> expr DIVINT expr .)
    IN              reduce using rule 35 (expr -> expr DIVINT expr .)
    CONS            reduce using rule 35 (expr -> expr DIVINT expr .)
    EQ              reduce using rule 35 (expr -> expr DIVINT expr .)
    COMMA           reduce using rule 35 (expr -> expr DIVINT expr .)
    R_BRACK         reduce using rule 35 (expr -> expr DIVINT expr .)
    R_PAREN         reduce using rule 35 (expr -> expr DIVINT expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 35 (expr -> expr DIVINT expr .) ]
  ! L_BRACK         [ reduce using rule 35 (expr -> expr DIVINT expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 74

    (36) expr -> expr DIV expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 36 (expr -> expr DIV expr .)
    MULT            reduce using rule 36 (expr -> expr DIV expr .)
    DIVINT          reduce using rule 36 (expr -> expr DIV expr .)
    DIV             reduce using rule 36 (expr -> expr DIV expr .)
    MOD             reduce using rule 36 (expr -> expr DIV expr .)
    PLUS            reduce using rule 36 (expr -> expr DIV expr .)
    MINUS           reduce using rule 36 (expr -> expr DIV expr .)
    AND_ALSO        reduce using rule 36 (expr -> expr DIV expr .)
    OR_ELSE         reduce using rule 36 (expr -> expr DIV expr .)
    LTE             reduce using rule 36 (expr -> expr DIV expr .)
    GTE             reduce using rule 36 (expr -> expr DIV expr .)
    EQ_EQ           reduce using rule 36 (expr -> expr DIV expr .)
    NEQ             reduce using rule 36 (expr -> expr DIV expr .)
    LT              reduce using rule 36 (expr -> expr DIV expr .)
    GT              reduce using rule 36 (expr -> expr DIV expr .)
    IN              reduce using rule 36 (expr -> expr DIV expr .)
    CONS            reduce using rule 36 (expr -> expr DIV expr .)
    EQ              reduce using rule 36 (expr -> expr DIV expr .)
    COMMA           reduce using rule 36 (expr -> expr DIV expr .)
    R_BRACK         reduce using rule 36 (expr -> expr DIV expr .)
    R_PAREN         reduce using rule 36 (expr -> expr DIV expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 36 (expr -> expr DIV expr .) ]
  ! L_BRACK         [ reduce using rule 36 (expr -> expr DIV expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 75

    (37) expr -> expr MOD expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 37 (expr -> expr MOD expr .)
    MULT            reduce using rule 37 (expr -> expr MOD expr .)
    DIVINT          reduce using rule 37 (expr -> expr MOD expr .)
    DIV             reduce using rule 37 (expr -> expr MOD expr .)
    MOD             reduce using rule 37 (expr -> expr MOD expr .)
    PLUS            reduce using rule 37 (expr -> expr MOD expr .)
    MINUS           reduce using rule 37 (expr -> expr MOD expr .)
    AND_ALSO        reduce using rule 37 (expr -> expr MOD expr .)
    OR_ELSE         reduce using rule 37 (expr -> expr MOD expr .)
    LTE             reduce using rule 37 (expr -> expr MOD expr .)
    GTE             reduce using rule 37 (expr -> expr MOD expr .)
    EQ_EQ           reduce using rule 37 (expr -> expr MOD expr .)
    NEQ             reduce using rule 37 (expr -> expr MOD expr .)
    LT              reduce using rule 37 (expr -> expr MOD expr .)
    GT              reduce using rule 37 (expr -> expr MOD expr .)
    IN              reduce using rule 37 (expr -> expr MOD expr .)
    CONS            reduce using rule 37 (expr -> expr MOD expr .)
    EQ              reduce using rule 37 (expr -> expr MOD expr .)
    COMMA           reduce using rule 37 (expr -> expr MOD expr .)
    R_BRACK         reduce using rule 37 (expr -> expr MOD expr .)
    R_PAREN         reduce using rule 37 (expr -> expr MOD expr .)
    POW             shift and go to state 35
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 37 (expr -> expr MOD expr .) ]
  ! L_BRACK         [ reduce using rule 37 (expr -> expr MOD expr .) ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 76

    (38) expr -> expr PLUS expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 38 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 38 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 38 (expr -> expr PLUS expr .)
    AND_ALSO        reduce using rule 38 (expr -> expr PLUS expr .)
    OR_ELSE         reduce using rule 38 (expr -> expr PLUS expr .)
    LTE             reduce using rule 38 (expr -> expr PLUS expr .)
    GTE             reduce using rule 38 (expr -> expr PLUS expr .)
    EQ_EQ           reduce using rule 38 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 38 (expr -> expr PLUS expr .)
    LT              reduce using rule 38 (expr -> expr PLUS expr .)
    GT              reduce using rule 38 (expr -> expr PLUS expr .)
    IN              reduce using rule 38 (expr -> expr PLUS expr .)
    CONS            reduce using rule 38 (expr -> expr PLUS expr .)
    EQ              reduce using rule 38 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 38 (expr -> expr PLUS expr .)
    R_BRACK         reduce using rule 38 (expr -> expr PLUS expr .)
    R_PAREN         reduce using rule 38 (expr -> expr PLUS expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! MULT            [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! DIVINT          [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! L_BRACK         [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 77

    (39) expr -> expr MINUS expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 39 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 39 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 39 (expr -> expr MINUS expr .)
    AND_ALSO        reduce using rule 39 (expr -> expr MINUS expr .)
    OR_ELSE         reduce using rule 39 (expr -> expr MINUS expr .)
    LTE             reduce using rule 39 (expr -> expr MINUS expr .)
    GTE             reduce using rule 39 (expr -> expr MINUS expr .)
    EQ_EQ           reduce using rule 39 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 39 (expr -> expr MINUS expr .)
    LT              reduce using rule 39 (expr -> expr MINUS expr .)
    GT              reduce using rule 39 (expr -> expr MINUS expr .)
    IN              reduce using rule 39 (expr -> expr MINUS expr .)
    CONS            reduce using rule 39 (expr -> expr MINUS expr .)
    EQ              reduce using rule 39 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 39 (expr -> expr MINUS expr .)
    R_BRACK         reduce using rule 39 (expr -> expr MINUS expr .)
    R_PAREN         reduce using rule 39 (expr -> expr MINUS expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! MULT            [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DIVINT          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! L_BRACK         [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 78

    (41) expr -> expr AND_ALSO expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 41 (expr -> expr AND_ALSO expr .)
    AND_ALSO        reduce using rule 41 (expr -> expr AND_ALSO expr .)
    OR_ELSE         reduce using rule 41 (expr -> expr AND_ALSO expr .)
    EQ              reduce using rule 41 (expr -> expr AND_ALSO expr .)
    COMMA           reduce using rule 41 (expr -> expr AND_ALSO expr .)
    R_BRACK         reduce using rule 41 (expr -> expr AND_ALSO expr .)
    R_PAREN         reduce using rule 41 (expr -> expr AND_ALSO expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! MULT            [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! DIVINT          [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! DIV             [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! MOD             [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! PLUS            [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! MINUS           [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! LTE             [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! GTE             [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! EQ_EQ           [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! NEQ             [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! LT              [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! GT              [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! IN              [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! CONS            [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! L_BRACK         [ reduce using rule 41 (expr -> expr AND_ALSO expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]


state 79

    (42) expr -> expr OR_ELSE expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 42 (expr -> expr OR_ELSE expr .)
    AND_ALSO        reduce using rule 42 (expr -> expr OR_ELSE expr .)
    OR_ELSE         reduce using rule 42 (expr -> expr OR_ELSE expr .)
    EQ              reduce using rule 42 (expr -> expr OR_ELSE expr .)
    COMMA           reduce using rule 42 (expr -> expr OR_ELSE expr .)
    R_BRACK         reduce using rule 42 (expr -> expr OR_ELSE expr .)
    R_PAREN         reduce using rule 42 (expr -> expr OR_ELSE expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! MULT            [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! DIVINT          [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! DIV             [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! MOD             [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! PLUS            [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! MINUS           [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! LTE             [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! GTE             [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! EQ_EQ           [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! NEQ             [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! LT              [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! GT              [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! IN              [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! CONS            [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! L_BRACK         [ reduce using rule 42 (expr -> expr OR_ELSE expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]


state 80

    (43) expr -> expr LTE expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 43 (expr -> expr LTE expr .)
    AND_ALSO        reduce using rule 43 (expr -> expr LTE expr .)
    OR_ELSE         reduce using rule 43 (expr -> expr LTE expr .)
    LTE             reduce using rule 43 (expr -> expr LTE expr .)
    GTE             reduce using rule 43 (expr -> expr LTE expr .)
    EQ_EQ           reduce using rule 43 (expr -> expr LTE expr .)
    NEQ             reduce using rule 43 (expr -> expr LTE expr .)
    LT              reduce using rule 43 (expr -> expr LTE expr .)
    GT              reduce using rule 43 (expr -> expr LTE expr .)
    EQ              reduce using rule 43 (expr -> expr LTE expr .)
    COMMA           reduce using rule 43 (expr -> expr LTE expr .)
    R_BRACK         reduce using rule 43 (expr -> expr LTE expr .)
    R_PAREN         reduce using rule 43 (expr -> expr LTE expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! MULT            [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! DIVINT          [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! DIV             [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! MOD             [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! PLUS            [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! MINUS           [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! IN              [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! CONS            [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! L_BRACK         [ reduce using rule 43 (expr -> expr LTE expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 81

    (44) expr -> expr GTE expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 44 (expr -> expr GTE expr .)
    AND_ALSO        reduce using rule 44 (expr -> expr GTE expr .)
    OR_ELSE         reduce using rule 44 (expr -> expr GTE expr .)
    LTE             reduce using rule 44 (expr -> expr GTE expr .)
    GTE             reduce using rule 44 (expr -> expr GTE expr .)
    EQ_EQ           reduce using rule 44 (expr -> expr GTE expr .)
    NEQ             reduce using rule 44 (expr -> expr GTE expr .)
    LT              reduce using rule 44 (expr -> expr GTE expr .)
    GT              reduce using rule 44 (expr -> expr GTE expr .)
    EQ              reduce using rule 44 (expr -> expr GTE expr .)
    COMMA           reduce using rule 44 (expr -> expr GTE expr .)
    R_BRACK         reduce using rule 44 (expr -> expr GTE expr .)
    R_PAREN         reduce using rule 44 (expr -> expr GTE expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! MULT            [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! DIVINT          [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! DIV             [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! MOD             [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! PLUS            [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! MINUS           [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! IN              [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! CONS            [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! L_BRACK         [ reduce using rule 44 (expr -> expr GTE expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 82

    (45) expr -> expr EQ_EQ expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 45 (expr -> expr EQ_EQ expr .)
    AND_ALSO        reduce using rule 45 (expr -> expr EQ_EQ expr .)
    OR_ELSE         reduce using rule 45 (expr -> expr EQ_EQ expr .)
    LTE             reduce using rule 45 (expr -> expr EQ_EQ expr .)
    GTE             reduce using rule 45 (expr -> expr EQ_EQ expr .)
    EQ_EQ           reduce using rule 45 (expr -> expr EQ_EQ expr .)
    NEQ             reduce using rule 45 (expr -> expr EQ_EQ expr .)
    LT              reduce using rule 45 (expr -> expr EQ_EQ expr .)
    GT              reduce using rule 45 (expr -> expr EQ_EQ expr .)
    EQ              reduce using rule 45 (expr -> expr EQ_EQ expr .)
    COMMA           reduce using rule 45 (expr -> expr EQ_EQ expr .)
    R_BRACK         reduce using rule 45 (expr -> expr EQ_EQ expr .)
    R_PAREN         reduce using rule 45 (expr -> expr EQ_EQ expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! MULT            [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! DIVINT          [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! DIV             [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! MOD             [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! PLUS            [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! MINUS           [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! IN              [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! CONS            [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! L_BRACK         [ reduce using rule 45 (expr -> expr EQ_EQ expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 83

    (46) expr -> expr NEQ expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 46 (expr -> expr NEQ expr .)
    AND_ALSO        reduce using rule 46 (expr -> expr NEQ expr .)
    OR_ELSE         reduce using rule 46 (expr -> expr NEQ expr .)
    LTE             reduce using rule 46 (expr -> expr NEQ expr .)
    GTE             reduce using rule 46 (expr -> expr NEQ expr .)
    EQ_EQ           reduce using rule 46 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 46 (expr -> expr NEQ expr .)
    LT              reduce using rule 46 (expr -> expr NEQ expr .)
    GT              reduce using rule 46 (expr -> expr NEQ expr .)
    EQ              reduce using rule 46 (expr -> expr NEQ expr .)
    COMMA           reduce using rule 46 (expr -> expr NEQ expr .)
    R_BRACK         reduce using rule 46 (expr -> expr NEQ expr .)
    R_PAREN         reduce using rule 46 (expr -> expr NEQ expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MULT            [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! DIVINT          [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! DIV             [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MOD             [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! PLUS            [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MINUS           [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! IN              [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! CONS            [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! L_BRACK         [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 84

    (47) expr -> expr LT expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 47 (expr -> expr LT expr .)
    AND_ALSO        reduce using rule 47 (expr -> expr LT expr .)
    OR_ELSE         reduce using rule 47 (expr -> expr LT expr .)
    LTE             reduce using rule 47 (expr -> expr LT expr .)
    GTE             reduce using rule 47 (expr -> expr LT expr .)
    EQ_EQ           reduce using rule 47 (expr -> expr LT expr .)
    NEQ             reduce using rule 47 (expr -> expr LT expr .)
    LT              reduce using rule 47 (expr -> expr LT expr .)
    GT              reduce using rule 47 (expr -> expr LT expr .)
    EQ              reduce using rule 47 (expr -> expr LT expr .)
    COMMA           reduce using rule 47 (expr -> expr LT expr .)
    R_BRACK         reduce using rule 47 (expr -> expr LT expr .)
    R_PAREN         reduce using rule 47 (expr -> expr LT expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! MULT            [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! DIVINT          [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! IN              [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! CONS            [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! L_BRACK         [ reduce using rule 47 (expr -> expr LT expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 85

    (48) expr -> expr GT expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 48 (expr -> expr GT expr .)
    AND_ALSO        reduce using rule 48 (expr -> expr GT expr .)
    OR_ELSE         reduce using rule 48 (expr -> expr GT expr .)
    LTE             reduce using rule 48 (expr -> expr GT expr .)
    GTE             reduce using rule 48 (expr -> expr GT expr .)
    EQ_EQ           reduce using rule 48 (expr -> expr GT expr .)
    NEQ             reduce using rule 48 (expr -> expr GT expr .)
    LT              reduce using rule 48 (expr -> expr GT expr .)
    GT              reduce using rule 48 (expr -> expr GT expr .)
    EQ              reduce using rule 48 (expr -> expr GT expr .)
    COMMA           reduce using rule 48 (expr -> expr GT expr .)
    R_BRACK         reduce using rule 48 (expr -> expr GT expr .)
    R_PAREN         reduce using rule 48 (expr -> expr GT expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! MULT            [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! DIVINT          [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! IN              [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! CONS            [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! L_BRACK         [ reduce using rule 48 (expr -> expr GT expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 86

    (49) expr -> expr IN expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 49 (expr -> expr IN expr .)
    AND_ALSO        reduce using rule 49 (expr -> expr IN expr .)
    OR_ELSE         reduce using rule 49 (expr -> expr IN expr .)
    LTE             reduce using rule 49 (expr -> expr IN expr .)
    GTE             reduce using rule 49 (expr -> expr IN expr .)
    EQ_EQ           reduce using rule 49 (expr -> expr IN expr .)
    NEQ             reduce using rule 49 (expr -> expr IN expr .)
    LT              reduce using rule 49 (expr -> expr IN expr .)
    GT              reduce using rule 49 (expr -> expr IN expr .)
    IN              reduce using rule 49 (expr -> expr IN expr .)
    CONS            reduce using rule 49 (expr -> expr IN expr .)
    EQ              reduce using rule 49 (expr -> expr IN expr .)
    COMMA           reduce using rule 49 (expr -> expr IN expr .)
    R_BRACK         reduce using rule 49 (expr -> expr IN expr .)
    R_PAREN         reduce using rule 49 (expr -> expr IN expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! MULT            [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! DIVINT          [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! DIV             [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! MOD             [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! PLUS            [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! MINUS           [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! L_BRACK         [ reduce using rule 49 (expr -> expr IN expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]


state 87

    (50) expr -> expr CONS expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 50 (expr -> expr CONS expr .)
    AND_ALSO        reduce using rule 50 (expr -> expr CONS expr .)
    OR_ELSE         reduce using rule 50 (expr -> expr CONS expr .)
    LTE             reduce using rule 50 (expr -> expr CONS expr .)
    GTE             reduce using rule 50 (expr -> expr CONS expr .)
    EQ_EQ           reduce using rule 50 (expr -> expr CONS expr .)
    NEQ             reduce using rule 50 (expr -> expr CONS expr .)
    LT              reduce using rule 50 (expr -> expr CONS expr .)
    GT              reduce using rule 50 (expr -> expr CONS expr .)
    EQ              reduce using rule 50 (expr -> expr CONS expr .)
    COMMA           reduce using rule 50 (expr -> expr CONS expr .)
    R_BRACK         reduce using rule 50 (expr -> expr CONS expr .)
    R_PAREN         reduce using rule 50 (expr -> expr CONS expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94

  ! POW             [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! MULT            [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! DIVINT          [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! DIV             [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! MOD             [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! PLUS            [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! MINUS           [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! IN              [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! CONS            [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! L_BRACK         [ reduce using rule 50 (expr -> expr CONS expr .) ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]


state 88

    (55) expr -> expr L_BRACK expr . R_BRACK
    (54) indexTkn -> L_BRACK expr . R_BRACK
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    R_BRACK         shift and go to state 102
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 89

    (28) assignment -> expr indexSequenceList EQ . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 103
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 90

    (52) indexSequenceList -> indexSequenceList indexTkn .

    EQ              reduce using rule 52 (indexSequenceList -> indexSequenceList indexTkn .)
    L_BRACK         reduce using rule 52 (indexSequenceList -> indexSequenceList indexTkn .)


state 91

    (54) indexTkn -> L_BRACK . expr R_BRACK
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 104
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 92

    (29) assignment -> expr EQ expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 29 (assignment -> expr EQ expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 93

    (30) expr -> HASHTAG INTEGER expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    POW             reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    MULT            reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    DIVINT          reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    DIV             reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    MOD             reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    PLUS            reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    MINUS           reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    AND_ALSO        reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    OR_ELSE         reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    LTE             reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    GTE             reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    EQ_EQ           reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    NEQ             reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    LT              reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    GT              reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    IN              reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    CONS            reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    L_BRACK         reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    EQ              reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    COMMA           reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    R_BRACK         reduce using rule 30 (expr -> HASHTAG INTEGER expr .)
    R_PAREN         reduce using rule 30 (expr -> HASHTAG INTEGER expr .)

  ! POW             [ shift and go to state 35 ]
  ! MULT            [ shift and go to state 36 ]
  ! DIVINT          [ shift and go to state 37 ]
  ! DIV             [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! AND_ALSO        [ shift and go to state 42 ]
  ! OR_ELSE         [ shift and go to state 43 ]
  ! LTE             [ shift and go to state 44 ]
  ! GTE             [ shift and go to state 45 ]
  ! EQ_EQ           [ shift and go to state 46 ]
  ! NEQ             [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! GT              [ shift and go to state 49 ]
  ! IN              [ shift and go to state 50 ]
  ! CONS            [ shift and go to state 51 ]
  ! L_BRACK         [ shift and go to state 94 ]


state 94

    (55) expr -> expr L_BRACK . expr R_BRACK
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 105
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 95

    (56) list -> L_BRACK sequence R_BRACK .

    SEMICOLON       reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    POW             reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    MULT            reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    DIVINT          reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    DIV             reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    MOD             reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    PLUS            reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    MINUS           reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    AND_ALSO        reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    OR_ELSE         reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    LTE             reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    GTE             reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    EQ_EQ           reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    NEQ             reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    LT              reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    GT              reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    IN              reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    CONS            reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    L_BRACK         reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    EQ              reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    COMMA           reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    R_BRACK         reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)
    R_PAREN         reduce using rule 56 (list -> L_BRACK sequence R_BRACK .)


state 96

    (58) sequence -> expr COMMA . sequence
    (58) sequence -> . expr COMMA sequence
    (59) sequence -> . expr
    (21) expr -> . INTEGER
    (22) expr -> . FLOAT
    (23) expr -> . STRING
    (24) expr -> . BOOLEAN
    (25) expr -> . VARIABLE
    (26) expr -> . list
    (27) expr -> . tuple
    (30) expr -> . HASHTAG INTEGER expr
    (33) expr -> . expr POW expr
    (34) expr -> . expr MULT expr
    (35) expr -> . expr DIVINT expr
    (36) expr -> . expr DIV expr
    (37) expr -> . expr MOD expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . MINUS expr
    (41) expr -> . expr AND_ALSO expr
    (42) expr -> . expr OR_ELSE expr
    (43) expr -> . expr LTE expr
    (44) expr -> . expr GTE expr
    (45) expr -> . expr EQ_EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr LT expr
    (48) expr -> . expr GT expr
    (49) expr -> . expr IN expr
    (50) expr -> . expr CONS expr
    (51) expr -> . NOT expr
    (55) expr -> . expr L_BRACK expr R_BRACK
    (60) expr -> . L_PAREN expr R_PAREN
    (56) list -> . L_BRACK sequence R_BRACK
    (57) list -> . L_BRACK R_BRACK
    (31) tuple -> . L_PAREN sequence R_PAREN
    (32) tuple -> . L_PAREN R_PAREN

    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    STRING          shift and go to state 13
    BOOLEAN         shift and go to state 14
    VARIABLE        shift and go to state 15
    HASHTAG         shift and go to state 18
    MINUS           shift and go to state 19
    NOT             shift and go to state 20
    L_PAREN         shift and go to state 22
    L_BRACK         shift and go to state 21

    expr                           shift and go to state 63
    sequence                       shift and go to state 106
    list                           shift and go to state 16
    tuple                          shift and go to state 17

state 97

    (60) expr -> L_PAREN expr R_PAREN .

    SEMICOLON       reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    POW             reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    MULT            reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    DIVINT          reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    DIV             reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    AND_ALSO        reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    OR_ELSE         reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    LTE             reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    GTE             reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    EQ_EQ           reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    NEQ             reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    IN              reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    CONS            reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    L_BRACK         reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    R_BRACK         reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 60 (expr -> L_PAREN expr R_PAREN .)


state 98

    (31) tuple -> L_PAREN sequence R_PAREN .

    SEMICOLON       reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    POW             reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    MULT            reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    DIVINT          reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    DIV             reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    MOD             reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    PLUS            reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    MINUS           reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    AND_ALSO        reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    OR_ELSE         reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    LTE             reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    GTE             reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    EQ_EQ           reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    NEQ             reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    LT              reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    GT              reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    IN              reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    CONS            reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    L_BRACK         reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    EQ              reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    COMMA           reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    R_BRACK         reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)
    R_PAREN         reduce using rule 31 (tuple -> L_PAREN sequence R_PAREN .)


state 99

    (13) print -> PRINT L_PAREN expr . R_PAREN
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    R_PAREN         shift and go to state 107
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 100

    (19) if -> IF L_PAREN expr . R_PAREN block
    (18) if_else -> IF L_PAREN expr . R_PAREN block ELSE block
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    R_PAREN         shift and go to state 108
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 101

    (20) while -> WHILE L_PAREN expr . R_PAREN block
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    R_PAREN         shift and go to state 109
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 102

    (55) expr -> expr L_BRACK expr R_BRACK .
    (54) indexTkn -> L_BRACK expr R_BRACK .

  ! reduce/reduce conflict for EQ resolved using rule 54 (indexTkn -> L_BRACK expr R_BRACK .)
  ! reduce/reduce conflict for L_BRACK resolved using rule 54 (indexTkn -> L_BRACK expr R_BRACK .)
    SEMICOLON       reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    POW             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    MULT            reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    DIVINT          reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    DIV             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    MOD             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    PLUS            reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    MINUS           reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    AND_ALSO        reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    OR_ELSE         reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    LTE             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    GTE             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    EQ_EQ           reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    NEQ             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    LT              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    GT              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    IN              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    CONS            reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    EQ              reduce using rule 54 (indexTkn -> L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 54 (indexTkn -> L_BRACK expr R_BRACK .)

  ! L_BRACK         [ reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .) ]
  ! EQ              [ reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .) ]


state 103

    (28) assignment -> expr indexSequenceList EQ expr .
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    SEMICOLON       reduce using rule 28 (assignment -> expr indexSequenceList EQ expr .)
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 104

    (54) indexTkn -> L_BRACK expr . R_BRACK
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    R_BRACK         shift and go to state 110
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 105

    (55) expr -> expr L_BRACK expr . R_BRACK
    (33) expr -> expr . POW expr
    (34) expr -> expr . MULT expr
    (35) expr -> expr . DIVINT expr
    (36) expr -> expr . DIV expr
    (37) expr -> expr . MOD expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (41) expr -> expr . AND_ALSO expr
    (42) expr -> expr . OR_ELSE expr
    (43) expr -> expr . LTE expr
    (44) expr -> expr . GTE expr
    (45) expr -> expr . EQ_EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . LT expr
    (48) expr -> expr . GT expr
    (49) expr -> expr . IN expr
    (50) expr -> expr . CONS expr
    (55) expr -> expr . L_BRACK expr R_BRACK

    R_BRACK         shift and go to state 111
    POW             shift and go to state 35
    MULT            shift and go to state 36
    DIVINT          shift and go to state 37
    DIV             shift and go to state 38
    MOD             shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    AND_ALSO        shift and go to state 42
    OR_ELSE         shift and go to state 43
    LTE             shift and go to state 44
    GTE             shift and go to state 45
    EQ_EQ           shift and go to state 46
    NEQ             shift and go to state 47
    LT              shift and go to state 48
    GT              shift and go to state 49
    IN              shift and go to state 50
    CONS            shift and go to state 51
    L_BRACK         shift and go to state 94


state 106

    (58) sequence -> expr COMMA sequence .

    R_BRACK         reduce using rule 58 (sequence -> expr COMMA sequence .)
    R_PAREN         reduce using rule 58 (sequence -> expr COMMA sequence .)


state 107

    (13) print -> PRINT L_PAREN expr R_PAREN .

    SEMICOLON       reduce using rule 13 (print -> PRINT L_PAREN expr R_PAREN .)


state 108

    (19) if -> IF L_PAREN expr R_PAREN . block
    (18) if_else -> IF L_PAREN expr R_PAREN . block ELSE block
    (11) block -> . LC block_list RC
    (12) block -> . LC RC

    LC              shift and go to state 6

    block                          shift and go to state 112

state 109

    (20) while -> WHILE L_PAREN expr R_PAREN . block
    (11) block -> . LC block_list RC
    (12) block -> . LC RC

    LC              shift and go to state 6

    block                          shift and go to state 113

state 110

    (54) indexTkn -> L_BRACK expr R_BRACK .

    EQ              reduce using rule 54 (indexTkn -> L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 54 (indexTkn -> L_BRACK expr R_BRACK .)


state 111

    (55) expr -> expr L_BRACK expr R_BRACK .

    POW             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    MULT            reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    DIVINT          reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    DIV             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    MOD             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    PLUS            reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    MINUS           reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    AND_ALSO        reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    OR_ELSE         reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    LTE             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    GTE             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    EQ_EQ           reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    NEQ             reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    LT              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    GT              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    IN              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    CONS            reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    L_BRACK         reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    SEMICOLON       reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    EQ              reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    COMMA           reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    R_BRACK         reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)
    R_PAREN         reduce using rule 55 (expr -> expr L_BRACK expr R_BRACK .)


state 112

    (19) if -> IF L_PAREN expr R_PAREN block .
    (18) if_else -> IF L_PAREN expr R_PAREN block . ELSE block

    INTEGER         reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    FLOAT           reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    STRING          reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    BOOLEAN         reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    VARIABLE        reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    HASHTAG         reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    MINUS           reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    NOT             reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    L_PAREN         reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    PRINT           reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    L_BRACK         reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    IF              reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    WHILE           reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    LC              reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    $end            reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    RC              reduce using rule 19 (if -> IF L_PAREN expr R_PAREN block .)
    ELSE            shift and go to state 114


state 113

    (20) while -> WHILE L_PAREN expr R_PAREN block .

    INTEGER         reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    FLOAT           reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    STRING          reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    BOOLEAN         reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    VARIABLE        reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    HASHTAG         reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    MINUS           reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    NOT             reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    L_PAREN         reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    PRINT           reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    L_BRACK         reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    IF              reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    WHILE           reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    LC              reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    $end            reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)
    RC              reduce using rule 20 (while -> WHILE L_PAREN expr R_PAREN block .)


state 114

    (18) if_else -> IF L_PAREN expr R_PAREN block ELSE . block
    (11) block -> . LC block_list RC
    (12) block -> . LC RC

    LC              shift and go to state 6

    block                          shift and go to state 115

state 115

    (18) if_else -> IF L_PAREN expr R_PAREN block ELSE block .

    INTEGER         reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    FLOAT           reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    STRING          reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    BOOLEAN         reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    VARIABLE        reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    HASHTAG         reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    MINUS           reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    NOT             reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    L_PAREN         reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    PRINT           reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    L_BRACK         reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    IF              reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    WHILE           reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    LC              reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    $end            reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)
    RC              reduce using rule 18 (if_else -> IF L_PAREN expr R_PAREN block ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INTEGER in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for STRING in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 3 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 3 resolved as shift
WARNING: shift/reduce conflict for HASHTAG in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for NOT in state 3 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for L_BRACK in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 29 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 29 resolved as shift
WARNING: shift/reduce conflict for STRING in state 29 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 29 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 29 resolved as shift
WARNING: shift/reduce conflict for HASHTAG in state 29 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 29 resolved as shift
WARNING: shift/reduce conflict for NOT in state 29 resolved as shift
WARNING: shift/reduce conflict for L_PAREN in state 29 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 29 resolved as shift
WARNING: shift/reduce conflict for L_BRACK in state 29 resolved as shift
WARNING: shift/reduce conflict for IF in state 29 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 29 resolved as shift
WARNING: shift/reduce conflict for R_PAREN in state 64 resolved as shift
WARNING: reduce/reduce conflict in state 102 resolved using rule (indexTkn -> L_BRACK expr R_BRACK)
WARNING: rejected rule (expr -> expr L_BRACK expr R_BRACK) in state 102
